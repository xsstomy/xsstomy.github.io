<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xsstomy</title>
    <description></description>
    <link>http://xsstomy/</link>
    <atom:link href="http://xsstomy/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 23 Aug 2016 23:00:39 +0800</pubDate>
    <lastBuildDate>Tue, 23 Aug 2016 23:00:39 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>半年总结</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;做完手术之后就一直处于萎靡状态，博客都停了，然后不知不觉2016已经过去了一半多。出来工作之后，总感觉时间过的飞快，一不小心半年过去了，然后一不小心又到年底了。年龄渐长，跟着而来的各种事情(年龄到了，大家都懂的)都来了。不过现在心态还好，事情来了，遇到问题想办法解决就好。这里强烈推荐大家去看一下&lt;a href=&quot;http://open.163.com/movie/2006/1/1/9/M6HV755O6_M6HV8DF19.html&quot;&gt;积极心理学&lt;/a&gt;,真的是非常棒的课程。写这篇博客的原因是看到了别人的半年总结，然后又翻了一下自己年初的计划，发现好多事情都跟不上计划，于是想重新调整一下计划，下面就总结一下上半年的事情和下半年事情的调整。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;上半年事情概述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;4月回武汉买房&lt;/li&gt;
  &lt;li&gt;4月辞职离开北京白鹭时代&lt;/li&gt;
  &lt;li&gt;4月回老家做手术&lt;/li&gt;
  &lt;li&gt;5月在家修养一个月&lt;/li&gt;
  &lt;li&gt;6月出来做事至今&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;买房是因为看到房价飞涨，怕以后连房子都买不起，15年二胎政策出来的时候就预测房价一定会上涨，但是由于自己内心不坚定，导致多花不少钱买房。以后做事，认准了就要坚持去做，免得后悔。&lt;/li&gt;
  &lt;li&gt;离开北京是因为北京空气和房价，压力太大了，再加上自己身体，在北京生活不习惯，然后就选择离开了北京。心里还是非常喜欢北京的同事的，喜欢那种工作氛围。&lt;/li&gt;
  &lt;li&gt;回家手术就是因为身体原因了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2016年上半年计划&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2015/12/31/11/2016.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;mvc结构没有整理，到最近熟悉单向数据流的时候，才有了更深刻的认识。&lt;/li&gt;
  &lt;li&gt;数据每月买几本，但是看的好像还真不多，准备列一下书单，每读完一本书写写总结。&lt;硅谷传奇&gt; &lt;浪潮之巅&gt; &lt;摄影构图学&gt;&lt;/摄影构图学&gt;&lt;/浪潮之巅&gt;&lt;/硅谷传奇&gt;&lt;/li&gt;
  &lt;li&gt;3d学习了一段时间，现在完全忘记了，也没有做相关的整理记录。“巧秀才跟不得烂笔头”这句话果然是真理。&lt;/li&gt;
  &lt;li&gt;由于五月在家休养，直到现在才纯纯的做reactjs开发。才熟悉webpack,reactjs等相关知识。&lt;/li&gt;
  &lt;li&gt;UI 学习自然是落下了。来到广州，前期一直处于加班状态。然后周末也重新捡起每周一次出去拍摄，技术方面的学习就自然落下了。中间一直在学习摄影和简单的后期，摄影技术和后期有一点点的增长。健身也重新捡起来了，每个一天锻炼一次，做it的还是需要有一个好的身体，其实做任何事情都需要一个好的健康的身体。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在越来越注重生活，工作并不是生活的全部。每周必然出去走一走晒晒太阳，因为每周上班都是呆在办公室，空调下，完全不怎么见太阳。出去的时候，一般带着相机到广州有名的建筑或者旅游景点逛一逛，还是非常不错的。有时候也参加一下知乎群的活动，认识一下新朋友，毕竟离开了熟悉的圈子，需要建立新的交际圈，认识新的朋友。&lt;/p&gt;

&lt;p&gt;经过上半年的计划和所做的事情，发现还是主抓1-2件事情，不要超过三件事情，要不然人会非常的累和疲惫，反而不易于事情做成。建议是计划1到2件主要的事情，坚持的做下去。偶尔中间穿插一下其它的事情。每周至少一天完全的休闲，不做任何工作相关的事情。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2016年下半年计划&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;英语雅思的考试准备(主)&lt;/li&gt;
  &lt;li&gt;摄影学习(主)&lt;/li&gt;
  &lt;li&gt;绘画(副)&lt;/li&gt;
  &lt;li&gt;python(副)&lt;/li&gt;
  &lt;li&gt;坚持锻炼身体，例行公事(就像每天早上起来刷牙一样的事情)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 17 Aug 2016 10:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/20160817%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/20160817%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93.html</guid>
        
        <category>总结</category>
        
        <category>2016</category>
        
        
      </item>
    
      <item>
        <title>手机微信端调试</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近使用reactjs开发单页应用，主要使用reactjs + webpack + redux + es2015(es6),因为使用了es2015 ，由于兼容性的问题，遇到一次比较坑的爬坑经历。情况是这样的，发布单页过后，在苹果手机微信中打开都是正常，在其他浏览器(chrome,safari)也是正常的；在安卓微信中都打不开,但是在chrome,qq浏览器也是正常的。当时就懵逼了，当时心里的状态是这样的，我靠，这是尼玛什么情况。没有办法，只能找办法调试解决了，但是要调试微信中的啊，其它浏览器中都是正常的啊，这时真是尴尬，完全不知道该如何调试手机端的微信(求心里阴影面积)。因为只在微信中出现，chrome中是正常的，那就不能使用chrome 调试方式了。这里是电脑调试手机端chrome方式&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/debug/remote-debugging/remote-debugging&quot;&gt;谷歌官方文档&lt;/a&gt;，再贴一个中文的&lt;a href=&quot;&quot;&gt;文档教程&lt;/a&gt;。最后找到微信web 开发者工具，最终调试成功。最终调试才知道是Object.assign 的兼容性问题，最后使用了&lt;a href=&quot;https://www.npmjs.com/package/object-assign&quot;&gt;object-assign&lt;/a&gt; 来解决兼容性的问题。下面来写一下这一次的详细调试过程。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;调试工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html&quot;&gt;微信web开发者工具&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;安卓手机一部&lt;/li&gt;
  &lt;li&gt;主要用到x5 blink 内核调试方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;步骤&lt;/h2&gt;

&lt;p&gt;1.前面的可以看官方的文档,按照微信官方文档中的准备工作做好，然后把安卓手机微信中X5 blink 的设置也设置好。然后分别重启手机中的微信和pc的微信web开发者工具。(这里被坑了一下，开始的时候死活不能调试，分别重启了一下手机和web开发者工具就可以调试了)&lt;/p&gt;

&lt;p&gt;这里是微信的开始调试之前的准备工作步骤，&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1455784140&amp;amp;token=&amp;amp;lang=zh_CN&quot;&gt;微信官方文档地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/weixin-debug-ready.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里贴一张我这里未开始调试的图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/debug-start.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.开始调试，请确保手机和微信web开发者工具都配置好，然后在web开发者工具中，选择X5 blink 调试， 然后就会弹出一个界面(移动调试，设备列表)， 如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/weixin-debug-start.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是官方文档的图。&lt;/p&gt;

&lt;p&gt;因为我这里没有安卓手机，所以只能先大概的文字描述一下。会有三种调试方式，一个chrome调试方式，一个是X5  blink调试方式，一个是代理的调试方式。这里我们要用的是X5 blink 调试。点击com.tencent.mm 下面的网页inspect，这时候我们就可以调试手机端的微信里面页面了，直接源码调试，可以查看各种源码了，还可以断点调试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/weixin-debug-debuging.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调试到这里基本就结束了，主要是调试的方式，微信web开发者工具还是不错的，可以直接远程调试手机端微信里面的网页了，不像以前只能alert调试，想想就好伤痛。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Aug 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/20160813%E5%AE%89%E5%8D%93%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95%E5%89%AF%E6%9C%AC.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/20160813%E5%AE%89%E5%8D%93%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95%E5%89%AF%E6%9C%AC.html</guid>
        
        <category>reactjs</category>
        
        <category>微信</category>
        
        <category>调试</category>
        
        
      </item>
    
      <item>
        <title>手机微信端调试</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近使用reactjs开发单页应用，主要使用reactjs + webpack + redux + es2015(es6),因为使用了es2015 ，由于兼容性的问题，遇到一次比较坑的爬坑经历。情况是这样的，发布单页过后，在苹果手机微信中打开都是正常，在其他浏览器(chrome,safari)也是正常的；在安卓微信中都打不开,但是在chrome,qq浏览器也是正常的。当时就懵逼了，当时心里的状态是这样的，我靠，这是尼玛什么情况。没有办法，只能找办法调试解决了，但是要调试微信中的啊，其它浏览器中都是正常的啊，这时真是尴尬，完全不知道该如何调试手机端的微信(求心里阴影面积)。因为只在微信中出现，chrome中是正常的，那就不能使用chrome 调试方式了。这里是电脑调试手机端chrome方式&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/debug/remote-debugging/remote-debugging&quot;&gt;谷歌官方文档&lt;/a&gt;，再贴一个中文的&lt;a href=&quot;&quot;&gt;文档教程&lt;/a&gt;。最后找到微信web 开发者工具，最终调试成功。最终调试才知道是Object.assign 的兼容性问题，最后使用了&lt;a href=&quot;https://www.npmjs.com/package/object-assign&quot;&gt;object-assign&lt;/a&gt; 来解决兼容性的问题。下面来写一下这一次的详细调试过程。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;调试工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html&quot;&gt;微信web开发者工具&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;安卓手机一部&lt;/li&gt;
  &lt;li&gt;主要用到x5 blink 内核调试方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;步骤&lt;/h2&gt;

&lt;p&gt;1.前面的可以看官方的文档,按照微信官方文档中的准备工作做好，然后把安卓手机微信中X5 blink 的设置也设置好。然后分别重启手机中的微信和pc的微信web开发者工具。(这里被坑了一下，开始的时候死活不能调试，分别重启了一下手机和web开发者工具就可以调试了)&lt;/p&gt;

&lt;p&gt;这里是微信的开始调试之前的准备工作步骤，&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1455784140&amp;amp;token=&amp;amp;lang=zh_CN&quot;&gt;微信官方文档地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/weixin-debug-ready.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里贴一张我这里未开始调试的图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/debug-start.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.开始调试，请确保手机和微信web开发者工具都配置好，然后在web开发者工具中，选择X5 blink 调试， 然后就会弹出一个界面(移动调试，设备列表)， 如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/weixin-debug-start.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是官方文档的图。&lt;/p&gt;

&lt;p&gt;因为我这里没有安卓手机，所以只能先大概的文字描述一下。会有三种调试方式，一个chrome调试方式，一个是X5  blink调试方式，一个是代理的调试方式。这里我们要用的是X5 blink 调试。点击com.tencent.mm 下面的网页inspect，这时候我们就可以调试手机端的微信里面页面了，直接源码调试，可以查看各种源码了，还可以断点调试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/weixin-debug-debuging.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调试到这里基本就结束了，主要是调试的方式，微信web开发者工具还是不错的，可以直接远程调试手机端微信里面的网页了，不像以前只能alert调试，想想就好伤痛。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Aug 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/20160813%E5%AE%89%E5%8D%93%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/20160813%E5%AE%89%E5%8D%93%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95.html</guid>
        
        <category>reactjs</category>
        
        <category>微信</category>
        
        <category>调试</category>
        
        
      </item>
    
      <item>
        <title>Sublime+iTerm2+EgretWing2.5+Webpack+ResDepot+chrome个人工作流</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;上周广州和深圳的白鹭开发者聚会，很遗憾没有时间参加，现在补这篇博客吧。这篇也算是继之前gulp的补充。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你的目标是打包runtime和使用官方打包成移动app的方式，那么这篇文章可能不是很适合你。当然也欢迎你阅读。&lt;/p&gt;

  &lt;p&gt;这里是打造个人个性的开发工作流，如果你喜欢折腾欢迎来尝试，毕竟官方的EgretWing 集成度已经是非常高的了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;需求&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;发布代码的版本控制&lt;/li&gt;
  &lt;li&gt;代码编辑器个人偏好&lt;/li&gt;
  &lt;li&gt;egret命令有时候gg&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;工具说明：&lt;/p&gt;

  &lt;p&gt;​		sublime text 3 代码编辑&lt;/p&gt;

 		iTerm2  终端工具&lt;br /&gt;

  &lt;p&gt;​		EgretWing2.5  UI编辑器，集成开发环境&lt;/p&gt;

  &lt;p&gt;​		ResDepot 资源编辑器&lt;/p&gt;

  &lt;p&gt;​		chrome 调试和预览工具&lt;/p&gt;

  &lt;p&gt;​		web pack 代码构建工具		&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;工作流配置&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sublime + egret + webpack + chrome + iTerm开发环境配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EgretWing2.5 + ResDepot UI编辑＋资源管理&lt;/p&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sublime-&quot;&gt;sublime 插件配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;https://github.com/Microsoft/TypeScript-Sublime-Plugin&lt;/li&gt;
  &lt;li&gt;https://github.com/jdc0589/JsFormat(保存代码自动格式化)&lt;/li&gt;
  &lt;li&gt;https://packagecontrol.io/packages/Seti_UI(主题看个人喜好)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sublimeiterm-&quot;&gt;sublime+iTerm 视窗配置&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/7/16/17/sublime+iTerm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://code.kpman.cc/2015/02/07/Sublime-%E8%88%87-iTerm-%E7%9A%84%E8%A6%96%E7%AA%97%E9%85%8D%E7%BD%AE/&quot;&gt;sublime+iTerm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;webpackegret-&quot;&gt;webpack＋egret 改造项目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;创建项目 &lt;/li&gt;
  &lt;li&gt;npm,git初始化&lt;/li&gt;
  &lt;li&gt;依赖库安装&lt;/li&gt;
  &lt;li&gt;webpack+tsconfig配置&lt;/li&gt;
  &lt;li&gt;修改原项目&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.创建项目&lt;/h4&gt;

&lt;p&gt;egret create web pack-egret - -type eui &lt;/p&gt;

&lt;h4 id=&quot;npm-init--git-init&quot;&gt;2. npm init &amp;amp; git init&lt;/h4&gt;

&lt;p&gt;/webpack-egret    npm init &lt;/p&gt;

&lt;p&gt;/webpack-egret   git init &lt;/p&gt;

&lt;h4 id=&quot;cnpm-install&quot;&gt;3. cnpm install&lt;/h4&gt;

&lt;p&gt;package.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.10.4&quot;,
    &quot;babel-loader&quot;: &quot;^6.2.4&quot;,
    &quot;babel-plugin-transform-es2015-arrow-functions&quot;: &quot;^6.8.0&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.9.0&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.9.0&quot;,
    &quot;babel-preset-react&quot;: &quot;^6.11.1&quot;,
    &quot;babel-preset-stage-0&quot;: &quot;^6.5.0&quot;,
    &quot;babel-runtime&quot;: &quot;^6.9.2&quot;,
    &quot;awesome-typescript-loader&quot;: &quot;^0.15.10&quot;,
    &quot;http-server&quot;: &quot;^0.9.0&quot;,
    &quot;strip-sourcemap-loader&quot;: &quot;0.0.1&quot;,
    &quot;typescript&quot;: &quot;^1.8.7&quot;,
    &quot;webpack&quot;: &quot;^1.12.14&quot;,
    &quot;webpack-dev-server&quot;: &quot;^1.14.1&quot;,
    &quot;webpack-merge&quot;: &quot;^0.14.0&quot;,
    &quot;webpack-validator&quot;: &quot;^2.2.2&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.22.0&quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;webpacktsconfig&quot;&gt;4.webpack+tsconfig配置&lt;/h4&gt;

&lt;p&gt;tsconfig.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
   &quot;compilerOptions&quot;: {
      &quot;target&quot;: &quot;ES5&quot;,
      &quot;outDir&quot;: &quot;bin-debug&quot;,
      &quot;sourceMap&quot;: true
   },
   &quot;exclude&quot;: [
      &quot;bin-debug&quot;,
      &quot;bin-release&quot;,
      &quot;resource&quot;,
      &quot;node_modules&quot;,
      &quot;bower_components&quot;
   ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpack.config.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var webpack = require(&#39;webpack&#39;);
var path = require(&#39;path&#39;)
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var paths = require(&#39;./webpack.paths&#39;)
var loaders = require(&#39;./webpack.loaders&#39;)


module.exports = {
	entry: {
		main: paths.app
	},
	resolve: {
		root: paths.app,
		extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.ts&#39;]
	},
	output: {
		path: paths.build,
		filename: &#39;bundle.js&#39;,
		publicPath: &#39;build/&#39;
	},
	devtool: &#39;eval-source-map&#39;,
	devServer: {
		historyApiFallback: true,
		hot: true,
		inline: true,
		progress: true
	},
	module: {
		loaders: loaders
	},
	plugins: [
		new webpack.NoErrorsPlugin(),
		new webpack.DefinePlugin({
			BUILD_MODE: JSON.stringify(&#39;development&#39;)
		})
	]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里给出的webpack配置的不全，后面会给出整个项目的github地址&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;...
&amp;lt;script src=&quot;libs/modules/egret/egret.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/egret/egret.web.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/game/game.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/game/game.web.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/tween/tween.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/res/res.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;build/bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;目录结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;|----index.html
|----src
|    |---- Main.ts
|    |---- LoadingUI.ts
|    |----Configure.ts
| 
|----build
|    
|----libs
|    |----modules
|
|----node_modules
|
|----resource
|    |----assets
|    |----config
|    |----default.res.json
|
|----tsconfig.json
|----package.json
|----webpack.config.js
|----webpack.loaders.js
|----webpack.paths.js
|----webpack.production.config.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;开发&lt;/h2&gt;

&lt;h2 id=&quot;npm-run-start&quot;&gt;1.npm run start&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;这样就不用egret命令啦。这里是热更新的，只需要修改代码，保存一下，然后在浏览器中刷新就可以看到最新的效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/7/16/17/chrome+debug.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;npm-run-build&quot;&gt;2. npm run build&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;发布之后需要上传的目录结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;|----index.html
|
|----src
|----build
|----libs
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考链接:&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://code.kpman.cc/2015/02/07/Sublime-%E8%88%87-iTerm-%E7%9A%84%E8%A6%96%E7%AA%97%E9%85%8D%E7%BD%AE/&quot;&gt;sublime+iterm&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://bbs.egret.com/forum.php?mod=viewthread&amp;amp;tid=17477&amp;amp;highlight=webpack&quot;&gt;webpack+egret&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://github.com/jdc0589/JsFormat&quot;&gt;sublime+jsFormat&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin&quot;&gt;sublime+typescript&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://zhaoda.net/webpack-handbook/index.html&quot;&gt;webpack-cn&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://webpack.github.io/docs/?utm_source=github&amp;amp;utm_medium=readme&amp;amp;utm_campaign=top&quot;&gt;webpack&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;推荐一下切图工具&lt;a href=&quot;http://www.fancynode.com.cn/&quot;&gt;pxcook&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Jul 2016 21:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/17%E5%89%8Degret%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/17%E5%89%8Degret%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81.html</guid>
        
        <category>egret</category>
        
        <category>工作流</category>
        
        
      </item>
    
      <item>
        <title>Sublime+iTerm2+EgretWing2.5+Webpack+ResDepot+chrome个人工作流</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;上周广州和深圳的白鹭开发者聚会，很遗憾没有时间参加，现在补这篇博客吧。这篇也算是继之前gulp的补充。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你的目标是打包runtime和使用官方打包成移动app的方式，那么这篇文章可能不是很适合你。当然也欢迎你阅读。&lt;/p&gt;

  &lt;p&gt;这里是打造个人个性的开发工作流，如果你喜欢折腾欢迎来尝试，毕竟官方的EgretWing 集成度已经是非常高的了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;伪需求&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;发布代码的版本控制(避免缓存)&lt;/li&gt;
  &lt;li&gt;代码编辑器个人偏好&lt;/li&gt;
  &lt;li&gt;egret命令有时候gg&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;工具说明：&lt;/p&gt;

  &lt;p&gt;​		sublime text 3 代码编辑&lt;/p&gt;

 		iTerm2  终端工具&lt;br /&gt;

  &lt;p&gt;​		EgretWing2.5  UI编辑器，集成开发环境&lt;/p&gt;

  &lt;p&gt;​		ResDepot 资源编辑器&lt;/p&gt;

  &lt;p&gt;​		chrome 调试和预览工具&lt;/p&gt;

  &lt;p&gt;​		web pack 代码构建工具		&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;工作流配置&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sublime + egret + webpack + chrome + iTerm开发环境配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EgretWing2.5 + ResDepot UI编辑＋资源管理&lt;/p&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sublime-&quot;&gt;sublime 插件配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;https://github.com/Microsoft/TypeScript-Sublime-Plugin&lt;/li&gt;
  &lt;li&gt;https://github.com/jdc0589/JsFormat(保存代码自动格式化)&lt;/li&gt;
  &lt;li&gt;https://packagecontrol.io/packages/Seti_UI(主题看个人喜好)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sublimeiterm-&quot;&gt;sublime+iTerm 视窗配置&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/7/16/17/sublime+iTerm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://code.kpman.cc/2015/02/07/Sublime-%E8%88%87-iTerm-%E7%9A%84%E8%A6%96%E7%AA%97%E9%85%8D%E7%BD%AE/&quot;&gt;sublime+iTerm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;webpackegret-&quot;&gt;webpack＋egret 改造项目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;创建项目 &lt;/li&gt;
  &lt;li&gt;npm,git初始化&lt;/li&gt;
  &lt;li&gt;依赖库安装&lt;/li&gt;
  &lt;li&gt;webpack+tsconfig配置&lt;/li&gt;
  &lt;li&gt;修改原项目&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.创建项目&lt;/h4&gt;

&lt;p&gt;egret create web pack-egret - -type eui &lt;/p&gt;

&lt;h4 id=&quot;npm-init--git-init&quot;&gt;2. npm init &amp;amp; git init&lt;/h4&gt;

&lt;p&gt;/webpack-egret    npm init &lt;/p&gt;

&lt;p&gt;/webpack-egret   git init &lt;/p&gt;

&lt;h4 id=&quot;npm-install&quot;&gt;3. npm install&lt;/h4&gt;

&lt;p&gt;package.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.10.4&quot;,
    &quot;babel-loader&quot;: &quot;^6.2.4&quot;,
    &quot;babel-plugin-transform-es2015-arrow-functions&quot;: &quot;^6.8.0&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.9.0&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.9.0&quot;,
    &quot;babel-preset-react&quot;: &quot;^6.11.1&quot;,
    &quot;babel-preset-stage-0&quot;: &quot;^6.5.0&quot;,
    &quot;babel-runtime&quot;: &quot;^6.9.2&quot;,
    &quot;awesome-typescript-loader&quot;: &quot;^0.15.10&quot;,
    &quot;http-server&quot;: &quot;^0.9.0&quot;,
    &quot;strip-sourcemap-loader&quot;: &quot;0.0.1&quot;,
    &quot;typescript&quot;: &quot;^1.8.7&quot;,
    &quot;webpack&quot;: &quot;^1.12.14&quot;,
    &quot;webpack-dev-server&quot;: &quot;^1.14.1&quot;,
    &quot;webpack-merge&quot;: &quot;^0.14.0&quot;,
    &quot;webpack-validator&quot;: &quot;^2.2.2&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.22.0&quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;webpacktsconfig&quot;&gt;4.webpack+tsconfig配置&lt;/h4&gt;

&lt;p&gt;tsconfig.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
   &quot;compilerOptions&quot;: {
      &quot;target&quot;: &quot;ES5&quot;,
      &quot;outDir&quot;: &quot;bin-debug&quot;,
      &quot;sourceMap&quot;: true
   },
   &quot;exclude&quot;: [
      &quot;bin-debug&quot;,
      &quot;bin-release&quot;,
      &quot;resource&quot;,
      &quot;node_modules&quot;,
      &quot;bower_components&quot;
   ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpack.config.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var webpack = require(&#39;webpack&#39;);
var path = require(&#39;path&#39;)
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var paths = require(&#39;./webpack.paths&#39;)
var loaders = require(&#39;./webpack.loaders&#39;)


module.exports = {
	entry: {
		main: paths.app
	},
	resolve: {
		root: paths.app,
		extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.ts&#39;]
	},
	output: {
		path: paths.build,
		filename: &#39;bundle.js&#39;,
		publicPath: &#39;build/&#39;
	},
	devtool: &#39;eval-source-map&#39;,
	devServer: {
		historyApiFallback: true,
		hot: true,
		inline: true,
		progress: true
	},
	module: {
		loaders: loaders
	},
	plugins: [
		new webpack.NoErrorsPlugin(),
		new webpack.DefinePlugin({
			BUILD_MODE: JSON.stringify(&#39;development&#39;)
		})
	]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里给出的webpack配置的不全，后面会给出整个项目的github地址&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;...
&amp;lt;script src=&quot;libs/modules/egret/egret.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/egret/egret.web.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/game/game.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/game/game.web.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/tween/tween.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/res/res.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;build/bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;目录结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;|----index.html
|----src
|    |---- Main.ts
|    |---- LoadingUI.ts
|    |----Configure.ts
| 
|----build
|    
|----libs
|    |----modules
|
|----node_modules
|
|----resource
|    |----assets
|    |----config
|    |----default.res.json
|
|----tsconfig.json
|----package.json
|----webpack.config.js
|----webpack.loaders.js
|----webpack.paths.js
|----webpack.production.config.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;开发&lt;/h2&gt;

&lt;h2 id=&quot;npm-run-start&quot;&gt;1.npm run start&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;这样就不用egret命令啦。这里是热更新的，只需要修改代码，保存一下，然后在浏览器中刷新就可以看到最新的效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/7/16/17/chrome+debug.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;npm-run-build&quot;&gt;2. npm run build&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;发布之后需要上传的目录结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;|----index.html
|
|----resource
|----build
|----libs
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考链接:&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://code.kpman.cc/2015/02/07/Sublime-%E8%88%87-iTerm-%E7%9A%84%E8%A6%96%E7%AA%97%E9%85%8D%E7%BD%AE/&quot;&gt;sublime+iterm&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://bbs.egret.com/forum.php?mod=viewthread&amp;amp;tid=17477&amp;amp;highlight=webpack&quot;&gt;webpack+egret&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://github.com/jdc0589/JsFormat&quot;&gt;sublime+jsFormat&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin&quot;&gt;sublime+typescript&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://zhaoda.net/webpack-handbook/index.html&quot;&gt;webpack-cn&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://webpack.github.io/docs/?utm_source=github&amp;amp;utm_medium=readme&amp;amp;utm_campaign=top&quot;&gt;webpack&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;推荐一下切图工具&lt;a href=&quot;http://www.fancynode.com.cn/&quot;&gt;pxcook&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Jul 2016 21:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/17.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/17.html</guid>
        
        <category>egret</category>
        
        <category>工作流</category>
        
        
      </item>
    
      <item>
        <title>electron环境搭建到项目发布</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近了解到electron，于是去简单的研究了一下。网上找个详细的教程，没有找到比较全的，然后就把整个流程简单的记录一下，方便需要的人。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;环境搭建&lt;/h2&gt;
&lt;p&gt;笔者这里使用的Mac，osx 10.11.3 ，在安装electron环境之前，确保本机已经安装&lt;strong&gt;Node.js&lt;/strong&gt;,&lt;strong&gt;Git&lt;/strong&gt;并确保尽可能的是最新的版本。笔者这里的Node版本4.2.2，Git版本2.5.4。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.切换镜像&lt;/h3&gt;
&lt;p&gt;按照官方的教程，是无法正常运行的这里，我们需要使用一下淘宝的镜像(&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;这里感谢淘宝&lt;/a&gt;)。这里我们在终端执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;electron&quot;&gt;2.安装electron&lt;/h3&gt;

&lt;p&gt;在终端执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnpm install electron-prebuilt -g
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.获取官方实例&lt;/h3&gt;
&lt;p&gt;在终端执行以下命令或者直接到&lt;a href=&quot;https://github.com/atom/electron-quick-start&quot;&gt;https://github.com/atom/electron-quick-start&lt;/a&gt;下载整个项目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/atom/electron-quick-start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;发布项目&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.安装打包工具&lt;/h3&gt;
&lt;p&gt;因为我们需要将我们的源代码进行混淆打包，免得别人看到源码。我们在终端执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g asar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.打包项目&lt;/h3&gt;

&lt;p&gt;命令 &lt;code&gt;asar pack|p [options] &amp;lt;dir&amp;gt; &amp;lt;output&amp;gt; &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里在终端进到刚才下载的官方例子文件夹外,执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asar p electron-quick-start app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改打包后的文件后缀，修改为app.asar。这里说明的是一定要以app为打包文件名称。打包之后然后到&lt;a href=&quot;https://github.com/atom/electron/releases&quot;&gt;https://github.com/atom/electron/releases&lt;/a&gt;。笔者这里是Mac系统，下载的是electron-v0.36.10-darwin-x64.zip。解压，把app.asar拷贝到&lt;code&gt;Electron.app/Contents/Resources/resource&lt;/code&gt;下,其它的不要做任何修改,到此算是完成源代码打包。&lt;/p&gt;

&lt;p&gt;还有修改应用名称，icon待续。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Mar 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/16-electron%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/16-electron%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8.html</guid>
        
        <category>electron</category>
        
        
      </item>
    
      <item>
        <title>electron环境搭建到项目发布</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近了解到electron，于是去简单的研究了一下。网上找个详细的教程，没有找到比较全的，然后就把整个流程简单的记录一下，方便需要的人。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;环境搭建&lt;/h2&gt;
&lt;p&gt;笔者这里使用的Mac，osx 10.11.3 ，在安装electron环境之前，确保本机已经安装&lt;strong&gt;Node.js&lt;/strong&gt;,&lt;strong&gt;Git&lt;/strong&gt;并确保尽可能的是最新的版本。笔者这里的Node版本4.2.2，Git版本2.5.4。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.切换镜像&lt;/h3&gt;
&lt;p&gt;按照官方的教程，是无法正常运行的这里，我们需要使用一下淘宝的镜像(&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;这里感谢淘宝&lt;/a&gt;)。这里我们在终端执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;electron&quot;&gt;2.安装electron&lt;/h3&gt;

&lt;p&gt;在终端执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnpm install electron-prebuilt -g
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.获取官方实例&lt;/h3&gt;
&lt;p&gt;在终端执行以下命令或者直接到&lt;a href=&quot;https://github.com/atom/electron-quick-start&quot;&gt;https://github.com/atom/electron-quick-start&lt;/a&gt;下载整个项目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/atom/electron-quick-start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;发布项目&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.安装打包工具&lt;/h3&gt;
&lt;p&gt;因为我们需要将我们的源代码进行混淆打包，免得别人看到源码。我们在终端执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g asar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.打包项目&lt;/h3&gt;

&lt;p&gt;命令 &lt;code&gt;asar pack|p [options] &amp;lt;dir&amp;gt; &amp;lt;output&amp;gt; &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里在终端进到刚才下载的官方例子文件夹外,执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asar p electron-quick-start app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改打包后的文件后缀，修改为app.asar。这里说明的是一定要以app为打包文件名称。打包之后然后到&lt;a href=&quot;https://github.com/atom/electron/releases&quot;&gt;https://github.com/atom/electron/releases&lt;/a&gt;。笔者这里是Mac系统，下载的是electron-v0.36.10-darwin-x64.zip。解压，把app.asar拷贝到&lt;code&gt;Electron.app/Contents/Resources/resource&lt;/code&gt;下,其它的不要做任何修改,到此算是完成源代码打包。&lt;/p&gt;

&lt;p&gt;还有修改应用名称，icon待续。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Mar 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/16.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/16.html</guid>
        
        <category>electron</category>
        
        
      </item>
    
      <item>
        <title>查找Node.js中JavaScript内存泄漏的简单教程</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;缘由&lt;/h3&gt;

&lt;p&gt;公司同事内部分享的一篇讲解查找内存泄漏的博客，个人觉得很赞，就决定翻译一下，翻译不重要的地方会略过。英文不太好，翻译不好的地方或者有错误的地方欢迎指正。 原博客链接&lt;a href=&quot;http://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/&quot;&gt;http://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;几个月前，有一次出现内存泄漏，不得不调试，查找问题所在。我查找了一些相关的资料和文章，但是认真仔细读过之后，还是有疑惑到底应该怎么去调试查找问题的所在。&lt;/p&gt;

&lt;p&gt;我希望这篇文章对查找node中的内存泄漏有一个简单的引导。我将使用一种简单的方式来引导查找内存泄漏的问题。个人认为这种方式可以满足大部分需求。对于某些情况，这种方式可能不行。我将提供一些其他的资料供你参考。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;最小理论&lt;/h3&gt;

&lt;p&gt;JavaScript是一种垃圾回收语言。因此，所有的内存使用都是由一个node进程来管理自动的分配和回收，通过V8 JavaSript引擎。&lt;/p&gt;

&lt;p&gt;V8 怎么知道什么时候去回收内存？在程序中，从跟节点开始，V8有数据图始终保存所有变量的。在JavaScript中有四种数据类型。真假值，字符串，数字和对象。前3种都是简单类型，这3种数据类型能够保存数据指向他们。对象和其它所有类型都是对象类型(数组也是对象类型)，都能保存引用指向其它的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/30/15/memory-graph.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;V8周期性的根据这个内存引用列表，试着查找一些从根节点无法查找到的数据。如果这些数据无法在根节点上查找到，V8 就确认这些数据不在被使用并且释放掉这些内存。这个机制被叫做垃圾回收。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;什么时候会发生内存泄漏？&lt;/h3&gt;

&lt;p&gt;在JavaScript中内存泄漏发生在当数据不需要，在根节点中依然可以查找到时。 V8 会认为这些数据依然在使用而且不会释放掉这些数据对应的内存。&lt;strong&gt;为了能够调试内存泄漏问题，我们需要保存该数据通过错误调用，并且确保V8 能够去清理掉&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;非常重要的是要记住，垃圾回收并不是每时每刻都在清理。一般V8 在认为合适的情况下会执行垃圾回收。例如，V8 会周期性的执行垃圾回收，或者当V8 发现剩余内存变少到一定量的时候也会执行一次垃圾回收。节点有所有变量的内存链连接所有的进程，因此V8能够智能地随时调用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/30/15/node-error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;未完待续。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Jan 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/15.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/15.html</guid>
        
        <category>内存泄漏</category>
        
        <category>Node.js</category>
        
        
      </item>
    
      <item>
        <title>查找Node.js中JavaScript内存泄漏的简单教程</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;缘由&lt;/h3&gt;

&lt;p&gt;公司同事内部分享的一篇讲解查找内存泄漏的博客，个人觉得很赞，就决定翻译一下，翻译不重要的地方会略过。英文不太好，翻译不好的地方或者有错误的地方欢迎指正。 原博客链接&lt;a href=&quot;http://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/&quot;&gt;http://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;几个月前，有一次出现内存泄漏，不得不调试，查找问题所在。我查找了一些相关的资料和文章，但是认真仔细读过之后，还是有疑惑到底应该怎么去调试查找问题的所在。&lt;/p&gt;

&lt;p&gt;我希望这篇文章对查找node中的内存泄漏有一个简单的引导。我将使用一种简单的方式来引导查找内存泄漏的问题。个人认为这种方式可以满足大部分需求。对于某些情况，这种方式可能不行。我将提供一些其他的资料供你参考。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;最小理论&lt;/h3&gt;

&lt;p&gt;JavaScript是一种垃圾回收语言。因此，所有的内存使用都是由一个node进程来管理自动的分配和回收，通过V8 JavaSript引擎。&lt;/p&gt;

&lt;p&gt;V8 怎么知道什么时候去回收内存？在程序中，从跟节点开始，V8有数据图始终保存所有变量的。在JavaScript中有四种数据类型。真假值，字符串，数字和对象。前3种都是简单类型，这3种数据类型能够保存数据指向他们。对象和其它所有类型都是对象类型(数组也是对象类型)，都能保存引用指向其它的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/30/15/memory-graph.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;V8周期性的根据这个内存引用列表，试着查找一些从根节点无法查找到的数据。如果这些数据无法在根节点上查找到，V8 就确认这些数据不在被使用并且释放掉这些内存。这个机制被叫做垃圾回收。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;什么时候会发生内存泄漏？&lt;/h3&gt;

&lt;p&gt;在JavaScript中内存泄漏发生在当数据不需要，在根节点中依然可以查找到时。 V8 会认为这些数据依然在使用而且不会释放掉这些数据对应的内存。&lt;strong&gt;为了能够调试内存泄漏问题，我们需要保存该数据通过错误调用，并且确保V8 能够去清理掉&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;非常重要的是要记住，垃圾回收并不是每时每刻都在清理。一般V8 在认为合适的情况下会执行垃圾回收。例如，V8 会周期性的执行垃圾回收，或者当V8 发现剩余内存变少到一定量的时候也会执行一次垃圾回收。节点有所有变量的内存链连接所有的进程，因此V8能够智能地随时调用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/30/15/node-error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;未完待续。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Jan 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/15.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/15.html</guid>
        
        <category>内存泄漏</category>
        
        <category>Node.js</category>
        
        
      </item>
    
      <item>
        <title>gulp在egret引擎中使用教程</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;缘由&lt;/h3&gt;

&lt;p&gt;作为一名伪前端攻城师，还是有必要学习一下前端工具和前端框架的。于是自己就折腾了一下，通过在egret引擎中使用gulp，来学习gulp的使用。这里是别人已经收集整理好的，gulp比较齐全的资料&lt;a href=&quot;https://github.com/Platform-CUF/use-gulp&quot;&gt;https://github.com/Platform-CUF/use-gulp&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;gulp&quot;&gt;gulp简介&lt;/h3&gt;

&lt;p&gt;Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。&lt;/p&gt;

&lt;p&gt;在egret中，这里就是希望使用它编译TypeScript文件，虽然egret已经做了一些封装，满足了基本的需求，这里完全就是自己折腾，用前端工具，做一些定制化的操作。然后实现一些定制化的功能，比如压缩资源。比如模块编译。等等。&lt;/p&gt;

&lt;h3 id=&quot;gulp-1&quot;&gt;gulp安装&lt;/h3&gt;

&lt;h4 id=&quot;gulp-2&quot;&gt;1.全局安装gulp：&lt;/h4&gt;

&lt;p&gt;&lt;code&gt; $ npm install gulp -g &lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果安装失败，前面可以添加一个sudo&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;sudo npm install gulp -g&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;因为可能被国内的某些原因，无法正常安装。大家可以安装&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;淘宝镜像&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;devdependencies&quot;&gt;2.作为项目的开发依赖（devDependencies）安装：&lt;/h4&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev gulp&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里是到项目根目录安装的。即egret项目的根目录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在egret项目根目录创建gulpfile.js文件。代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
gulp.task(&#39;default&#39;, function() {
  // 将你的默认的任务代码放在这
  
  console.log(&quot;hello gulp&quot;)
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入:&lt;code&gt;gulp&lt;/code&gt; , &lt;br /&gt;
终端输出内容中会有单独的一行，显示内容为&lt;code&gt; hello gulp&lt;/code&gt;;&lt;/p&gt;

&lt;h4 id=&quot;typescript&quot;&gt;3.编译TypeScript&lt;/h4&gt;

&lt;p&gt;在egret中，输入egret  build  则egret引擎会构建项目，TypeScript文件生成对应JavaScript文件，文件生成的目录是bin-debug。&lt;/p&gt;

&lt;p&gt;在这里使用gulp来构建，我们同样默认还是生成在bin-debug文件目录下。&lt;br /&gt;
在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev gulp-typescript&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在egret中，构建项目使用的命令是egret  build ,这里我们就创建一个build任务,gulpfile.js编写代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;)
gulp.task(&#39;default&#39;, function() {
  // 将你的默认的任务代码放在这
   console.log(&quot;hello gulp&quot;);
});

//创建一个build 任务
gulp.task(&#39;build&#39;, function() {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
        	  &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入: gulp build ,&lt;br /&gt;
我们查看对应的bin-debug目录下的JavaScript文件，是完全对应TypeScript文件生成的。&lt;br /&gt;
这里我们就实现了egret  build 功能。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里在终端输入gulp build 时候，终端会输出比较多的错误提示，说是没有引用对应的库文件。&lt;br /&gt;
接下来我们解决这个报错问题，我们引用新的gulp插件，直接调用egret默认提供的命令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev gulp-shell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们用shell脚本，调用egret引擎默认提供的命令功能。在gulpfile.js中编写对应的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});


gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用egret run －a 命令,实现增量编译
gulp.task(&#39;run&#39;, function(){
   gulp.src(&#39;&#39;)
   .pipe(shell([
       &#39;egret build -e&#39;,
       &#39;egret run -a&#39;
   ]))
    
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;egret&quot;&gt;4.发布Egret项目&lt;/h4&gt;

&lt;p&gt;这里我们同样使用egret自带的命令。参考步骤3中编译操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish
gulp.task(&#39;publish&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish &#39; 
        ]))
})


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;发布我们这里基本的已经实现了，但是egret官方提供的可以默认的添加版本号，这里我们用另外的插&lt;br /&gt;
件yargs来实现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev yargs&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;gulpfile.js中添加代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);
var argv = require(&#39;yargs&#39;).argv;

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish --version 1000
gulp.task(&#39;publish&#39;, function () {

    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish --version &#39; +argv.version
        ]))
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，我们就完成了egret提供的基本相同的功能。剩下的就是我们的自定义功能了。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;5.自定义功能&lt;/h4&gt;

&lt;h5 id=&quot;section-2&quot;&gt;5.1压缩图片资源&lt;/h5&gt;

&lt;p&gt;安装压缩插件，在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev gulp-imagemin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后新建一个imagemin的任务，代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);
var argv = require(&#39;yargs&#39;).argv;
var image = require(&#39;gulp-imagemin&#39;);


gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish --version 1000
gulp.task(&#39;publish&#39;, function () {

    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish --version &#39; + argv.version
        ]))
})


// 压缩图片功能 gulp imagemin
gulp.task(&#39;imagemin&#39;, function () {
    gulp.src(&#39;resource/**/*.{png,jpg,gif}&#39;)
        .pipe(image({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            interlaced: true //类型：Boolean 默认：false 隔行扫描gif进行渲染
           
        }))
        .pipe(gulp.dest(&#39;bin-release/resource&#39;));
});


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合imagemin-pngquant 来实现深度压缩资源。&lt;br /&gt;
安装压缩插件，在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install imagemin-pngquant --save-dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后修改一下资源压缩代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);
var argv = require(&#39;yargs&#39;).argv;
var image = require(&#39;gulp-imagemin&#39;);
var pngquant = require(&#39;imagemin-pngquant&#39;);

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish --version 1000
gulp.task(&#39;publish&#39;, function () {

    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish --version &#39; + argv.version
        ]))
})


// 压缩图片功能 gulp imagemin
gulp.task(&#39;imagemin&#39;, function () {
    gulp.src(&#39;resource/**/*.{png,jpg,gif}&#39;)
        .pipe(image({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            use: [pngquant()]//使用pngquant深度压缩png图片的imagemin插件
        }))
        .pipe(gulp.dest(&#39;bin-release/resource&#39;));
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的压缩是全部压缩，如何实现增量压缩资源，这里使用其它的插件来实现。&lt;br /&gt;
安装压缩插件，在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install gulp-cache --save-dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;修改gulpfile.js代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);
var argv = require(&#39;yargs&#39;).argv;
var image = require(&#39;gulp-imagemin&#39;);
var pngquant = require(&#39;imagemin-pngquant&#39;);
var cache = require(&#39;gulp-cache&#39;);

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish --version 1000
gulp.task(&#39;publish&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish --version &#39; + argv.version
        ]))
})


// 压缩图片功能 gulp imagemin
gulp.task(&#39;imagemin&#39;, function () {
    gulp.src(&#39;resource/**/*.{png,jpg,gif}&#39;)
        .pipe(cache(image({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            use: [pngquant()]//使用pngquant深度压缩png图片的imagemin插件
        })))
        .pipe(gulp.dest(&#39;bin-release/resource&#39;));//压缩资源后的保存路径，这里可以填写发布后的路径
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-3&quot;&gt;5.2添加版本控制&lt;/h5&gt;

&lt;p&gt;未完待续…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/14.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/14.html</guid>
        
        <category>egret</category>
        
        <category>gulp</category>
        
        
      </item>
    
  </channel>
</rss>
