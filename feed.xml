<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xsstomy</title>
    <description></description>
    <link>http://xsstomy/</link>
    <atom:link href="http://xsstomy/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 23 Aug 2016 23:53:56 +0800</pubDate>
    <lastBuildDate>Tue, 23 Aug 2016 23:53:56 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>半年总结</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;做完手术之后就一直处于萎靡状态，博客都停了，然后不知不觉2016已经过去了一半多。出来工作之后，总感觉时间过的飞快，一不小心半年过去了，然后一不小心又到年底了。年龄渐长，跟着而来的各种事情(年龄到了，大家都懂的)都来了。不过现在心态还好，事情来了，遇到问题想办法解决就好。这里强烈推荐大家去看一下&lt;a href=&quot;http://open.163.com/movie/2006/1/1/9/M6HV755O6_M6HV8DF19.html&quot;&gt;积极心理学&lt;/a&gt;,真的是非常棒的课程。写这篇博客的原因是看到了别人的半年总结，然后又翻了一下自己年初的计划，发现好多事情都跟不上计划，于是想重新调整一下计划，下面就总结一下上半年的事情和下半年事情的调整。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;上半年事情概述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;4月回武汉买房&lt;/li&gt;
  &lt;li&gt;4月辞职离开北京白鹭时代&lt;/li&gt;
  &lt;li&gt;4月回老家做手术&lt;/li&gt;
  &lt;li&gt;5月在家修养一个月&lt;/li&gt;
  &lt;li&gt;6月出来做事至今&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;买房是因为看到房价飞涨，怕以后连房子都买不起，15年二胎政策出来的时候就预测房价一定会上涨，但是由于自己内心不坚定，导致多花不少钱买房。以后做事，认准了就要坚持去做，免得后悔。&lt;/li&gt;
  &lt;li&gt;离开北京是因为北京空气和房价，压力太大了，再加上自己身体，在北京生活不习惯，然后就选择离开了北京。心里还是非常喜欢北京的同事的，喜欢那种工作氛围。&lt;/li&gt;
  &lt;li&gt;回家手术就是因为身体原因了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2016年上半年计划&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2015/12/31/11/2016.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;mvc结构没有整理，到最近熟悉单向数据流的时候，才有了更深刻的认识。&lt;/li&gt;
  &lt;li&gt;数据每月买几本，但是看的好像还真不多，准备列一下书单，每读完一本书写写总结。&lt;硅谷传奇&gt; &lt;浪潮之巅&gt; &lt;摄影构图学&gt;&lt;/摄影构图学&gt;&lt;/浪潮之巅&gt;&lt;/硅谷传奇&gt;&lt;/li&gt;
  &lt;li&gt;3d学习了一段时间，现在完全忘记了，也没有做相关的整理记录。“巧秀才跟不得烂笔头”这句话果然是真理。&lt;/li&gt;
  &lt;li&gt;由于五月在家休养，直到现在才纯纯的做reactjs开发。才熟悉webpack,reactjs等相关知识。&lt;/li&gt;
  &lt;li&gt;UI 学习自然是落下了。来到广州，前期一直处于加班状态。然后周末也重新捡起每周一次出去拍摄，技术方面的学习就自然落下了。中间一直在学习摄影和简单的后期，摄影技术和后期有一点点的增长。健身也重新捡起来了，每个一天锻炼一次，做it的还是需要有一个好的身体，其实做任何事情都需要一个好的健康的身体。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在越来越注重生活，工作并不是生活的全部。每周必然出去走一走晒晒太阳，因为每周上班都是呆在办公室，空调下，完全不怎么见太阳。出去的时候，一般带着相机到广州有名的建筑或者旅游景点逛一逛，还是非常不错的。有时候也参加一下知乎群的活动，认识一下新朋友，毕竟离开了熟悉的圈子，需要建立新的交际圈，认识新的朋友。&lt;/p&gt;

&lt;p&gt;经过上半年的计划和所做的事情，发现还是主抓1-2件事情，不要超过三件事情，要不然人会非常的累和疲惫，反而不易于事情做成。建议是计划1到2件主要的事情，坚持的做下去。偶尔中间穿插一下其它的事情。每周至少一天完全的休闲，不做任何工作相关的事情。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2016年下半年计划&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;英语雅思的考试准备(主)&lt;/li&gt;
  &lt;li&gt;摄影学习(主)&lt;/li&gt;
  &lt;li&gt;绘画(副)&lt;/li&gt;
  &lt;li&gt;python(副)&lt;/li&gt;
  &lt;li&gt;坚持锻炼身体，例行公事(就像每天早上起来刷牙一样的事情)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 17 Aug 2016 10:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/20160817%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/20160817%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93.html</guid>
        
        <category>总结</category>
        
        <category>2016</category>
        
        
      </item>
    
      <item>
        <title>手机微信端调试</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近使用reactjs开发单页应用，主要使用reactjs + webpack + redux + es2015(es6),因为使用了es2015 ，由于兼容性的问题，遇到一次比较坑的爬坑经历。情况是这样的，发布单页过后，在苹果手机微信中打开都是正常，在其他浏览器(chrome,safari)也是正常的；在安卓微信中都打不开,但是在chrome,qq浏览器也是正常的。当时就懵逼了，当时心里的状态是这样的，我靠，这是尼玛什么情况。没有办法，只能找办法调试解决了，但是要调试微信中的啊，其它浏览器中都是正常的啊，这时真是尴尬，完全不知道该如何调试手机端的微信(求心里阴影面积)。因为只在微信中出现，chrome中是正常的，那就不能使用chrome 调试方式了。这里是电脑调试手机端chrome方式&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/debug/remote-debugging/remote-debugging&quot;&gt;谷歌官方文档&lt;/a&gt;，再贴一个中文的&lt;a href=&quot;&quot;&gt;文档教程&lt;/a&gt;。最后找到微信web 开发者工具，最终调试成功。最终调试才知道是Object.assign 的兼容性问题，最后使用了&lt;a href=&quot;https://www.npmjs.com/package/object-assign&quot;&gt;object-assign&lt;/a&gt; 来解决兼容性的问题。下面来写一下这一次的详细调试过程。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;调试工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html&quot;&gt;微信web开发者工具&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;安卓手机一部&lt;/li&gt;
  &lt;li&gt;主要用到x5 blink 内核调试方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;步骤&lt;/h2&gt;

&lt;p&gt;1.前面的可以看官方的文档,按照微信官方文档中的准备工作做好，然后把安卓手机微信中X5 blink 的设置也设置好。然后分别重启手机中的微信和pc的微信web开发者工具。(这里被坑了一下，开始的时候死活不能调试，分别重启了一下手机和web开发者工具就可以调试了)&lt;/p&gt;

&lt;p&gt;这里是微信的开始调试之前的准备工作步骤，&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1455784140&amp;amp;token=&amp;amp;lang=zh_CN&quot;&gt;微信官方文档地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/weixin-debug-ready.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里贴一张我这里未开始调试的图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/debug-start.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.开始调试，请确保手机和微信web开发者工具都配置好，然后在web开发者工具中，选择X5 blink 调试， 然后就会弹出一个界面(移动调试，设备列表)， 如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/weixin-debug-start.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是官方文档的图。&lt;/p&gt;

&lt;p&gt;因为我这里没有安卓手机，所以只能先大概的文字描述一下。会有三种调试方式，一个chrome调试方式，一个是X5  blink调试方式，一个是代理的调试方式。这里我们要用的是X5 blink 调试。点击com.tencent.mm 下面的网页inspect，这时候我们就可以调试手机端的微信里面页面了，直接源码调试，可以查看各种源码了，还可以断点调试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/08/13/weixin-debug-debuging.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调试到这里基本就结束了，主要是调试的方式，微信web开发者工具还是不错的，可以直接远程调试手机端微信里面的网页了，不像以前只能alert调试，想想就好伤痛。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Aug 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/20160813%E5%AE%89%E5%8D%93%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/20160813%E5%AE%89%E5%8D%93%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95.html</guid>
        
        <category>reactjs</category>
        
        <category>微信</category>
        
        <category>调试</category>
        
        
      </item>
    
      <item>
        <title>Sublime+iTerm2+EgretWing2.5+Webpack+ResDepot+chrome个人工作流</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;上周广州和深圳的白鹭开发者聚会，很遗憾没有时间参加，现在补这篇博客吧。这篇也算是继之前gulp的补充。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你的目标是打包runtime和使用官方打包成移动app的方式，那么这篇文章可能不是很适合你。当然也欢迎你阅读。&lt;/p&gt;

  &lt;p&gt;这里是打造个人个性的开发工作流，如果你喜欢折腾欢迎来尝试，毕竟官方的EgretWing 集成度已经是非常高的了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;需求&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;发布代码的版本控制&lt;/li&gt;
  &lt;li&gt;代码编辑器个人偏好&lt;/li&gt;
  &lt;li&gt;egret命令有时候gg&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;工具说明：&lt;/p&gt;

  &lt;p&gt;​		sublime text 3 代码编辑&lt;/p&gt;

 		iTerm2  终端工具&lt;br /&gt;

  &lt;p&gt;​		EgretWing2.5  UI编辑器，集成开发环境&lt;/p&gt;

  &lt;p&gt;​		ResDepot 资源编辑器&lt;/p&gt;

  &lt;p&gt;​		chrome 调试和预览工具&lt;/p&gt;

  &lt;p&gt;​		web pack 代码构建工具		&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;工作流配置&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;sublime + egret + webpack + chrome + iTerm开发环境配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EgretWing2.5 + ResDepot UI编辑＋资源管理&lt;/p&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sublime-&quot;&gt;sublime 插件配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;https://github.com/Microsoft/TypeScript-Sublime-Plugin&lt;/li&gt;
  &lt;li&gt;https://github.com/jdc0589/JsFormat(保存代码自动格式化)&lt;/li&gt;
  &lt;li&gt;https://packagecontrol.io/packages/Seti_UI(主题看个人喜好)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sublimeiterm-&quot;&gt;sublime+iTerm 视窗配置&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/7/16/17/sublime+iTerm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://code.kpman.cc/2015/02/07/Sublime-%E8%88%87-iTerm-%E7%9A%84%E8%A6%96%E7%AA%97%E9%85%8D%E7%BD%AE/&quot;&gt;sublime+iTerm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;webpackegret-&quot;&gt;webpack＋egret 改造项目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;创建项目 &lt;/li&gt;
  &lt;li&gt;npm,git初始化&lt;/li&gt;
  &lt;li&gt;依赖库安装&lt;/li&gt;
  &lt;li&gt;webpack+tsconfig配置&lt;/li&gt;
  &lt;li&gt;修改原项目&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.创建项目&lt;/h4&gt;

&lt;p&gt;egret create web pack-egret - -type eui &lt;/p&gt;

&lt;h4 id=&quot;npm-init--git-init&quot;&gt;2. npm init &amp;amp; git init&lt;/h4&gt;

&lt;p&gt;/webpack-egret    npm init &lt;/p&gt;

&lt;p&gt;/webpack-egret   git init &lt;/p&gt;

&lt;h4 id=&quot;cnpm-install&quot;&gt;3. cnpm install&lt;/h4&gt;

&lt;p&gt;package.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.10.4&quot;,
    &quot;babel-loader&quot;: &quot;^6.2.4&quot;,
    &quot;babel-plugin-transform-es2015-arrow-functions&quot;: &quot;^6.8.0&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.9.0&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.9.0&quot;,
    &quot;babel-preset-react&quot;: &quot;^6.11.1&quot;,
    &quot;babel-preset-stage-0&quot;: &quot;^6.5.0&quot;,
    &quot;babel-runtime&quot;: &quot;^6.9.2&quot;,
    &quot;awesome-typescript-loader&quot;: &quot;^0.15.10&quot;,
    &quot;http-server&quot;: &quot;^0.9.0&quot;,
    &quot;strip-sourcemap-loader&quot;: &quot;0.0.1&quot;,
    &quot;typescript&quot;: &quot;^1.8.7&quot;,
    &quot;webpack&quot;: &quot;^1.12.14&quot;,
    &quot;webpack-dev-server&quot;: &quot;^1.14.1&quot;,
    &quot;webpack-merge&quot;: &quot;^0.14.0&quot;,
    &quot;webpack-validator&quot;: &quot;^2.2.2&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.22.0&quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;webpacktsconfig&quot;&gt;4.webpack+tsconfig配置&lt;/h4&gt;

&lt;p&gt;tsconfig.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
   &quot;compilerOptions&quot;: {
      &quot;target&quot;: &quot;ES5&quot;,
      &quot;outDir&quot;: &quot;bin-debug&quot;,
      &quot;sourceMap&quot;: true
   },
   &quot;exclude&quot;: [
      &quot;bin-debug&quot;,
      &quot;bin-release&quot;,
      &quot;resource&quot;,
      &quot;node_modules&quot;,
      &quot;bower_components&quot;
   ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpack.config.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var webpack = require(&#39;webpack&#39;);
var path = require(&#39;path&#39;)
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var paths = require(&#39;./webpack.paths&#39;)
var loaders = require(&#39;./webpack.loaders&#39;)


module.exports = {
	entry: {
		main: paths.app
	},
	resolve: {
		root: paths.app,
		extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.ts&#39;]
	},
	output: {
		path: paths.build,
		filename: &#39;bundle.js&#39;,
		publicPath: &#39;build/&#39;
	},
	devtool: &#39;eval-source-map&#39;,
	devServer: {
		historyApiFallback: true,
		hot: true,
		inline: true,
		progress: true
	},
	module: {
		loaders: loaders
	},
	plugins: [
		new webpack.NoErrorsPlugin(),
		new webpack.DefinePlugin({
			BUILD_MODE: JSON.stringify(&#39;development&#39;)
		})
	]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里给出的webpack配置的不全，后面会给出整个项目的github地址&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;...
&amp;lt;script src=&quot;libs/modules/egret/egret.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/egret/egret.web.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/game/game.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/game/game.web.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/tween/tween.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libs/modules/res/res.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;build/bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;目录结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;|----index.html
|----src
|    |---- Main.ts
|    |---- LoadingUI.ts
|    |----Configure.ts
| 
|----build
|    
|----libs
|    |----modules
|
|----node_modules
|
|----resource
|    |----assets
|    |----config
|    |----default.res.json
|
|----tsconfig.json
|----package.json
|----webpack.config.js
|----webpack.loaders.js
|----webpack.paths.js
|----webpack.production.config.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;开发&lt;/h2&gt;

&lt;h2 id=&quot;npm-run-start&quot;&gt;1.npm run start&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;这样就不用egret命令啦。这里是热更新的，只需要修改代码，保存一下，然后在浏览器中刷新就可以看到最新的效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/7/16/17/chrome+debug.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;npm-run-build&quot;&gt;2. npm run build&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;发布之后需要上传的目录结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;|----index.html
|
|----src
|----build
|----libs
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考链接:&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://code.kpman.cc/2015/02/07/Sublime-%E8%88%87-iTerm-%E7%9A%84%E8%A6%96%E7%AA%97%E9%85%8D%E7%BD%AE/&quot;&gt;sublime+iterm&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://bbs.egret.com/forum.php?mod=viewthread&amp;amp;tid=17477&amp;amp;highlight=webpack&quot;&gt;webpack+egret&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://github.com/jdc0589/JsFormat&quot;&gt;sublime+jsFormat&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin&quot;&gt;sublime+typescript&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://zhaoda.net/webpack-handbook/index.html&quot;&gt;webpack-cn&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://webpack.github.io/docs/?utm_source=github&amp;amp;utm_medium=readme&amp;amp;utm_campaign=top&quot;&gt;webpack&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;推荐一下切图工具&lt;a href=&quot;http://www.fancynode.com.cn/&quot;&gt;pxcook&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Jul 2016 21:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/17%E5%89%8Degret%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/17%E5%89%8Degret%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81.html</guid>
        
        <category>egret</category>
        
        <category>工作流</category>
        
        
      </item>
    
      <item>
        <title>electron环境搭建到项目发布</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近了解到electron，于是去简单的研究了一下。网上找个详细的教程，没有找到比较全的，然后就把整个流程简单的记录一下，方便需要的人。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;环境搭建&lt;/h2&gt;
&lt;p&gt;笔者这里使用的Mac，osx 10.11.3 ，在安装electron环境之前，确保本机已经安装&lt;strong&gt;Node.js&lt;/strong&gt;,&lt;strong&gt;Git&lt;/strong&gt;并确保尽可能的是最新的版本。笔者这里的Node版本4.2.2，Git版本2.5.4。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.切换镜像&lt;/h3&gt;
&lt;p&gt;按照官方的教程，是无法正常运行的这里，我们需要使用一下淘宝的镜像(&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;这里感谢淘宝&lt;/a&gt;)。这里我们在终端执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;electron&quot;&gt;2.安装electron&lt;/h3&gt;

&lt;p&gt;在终端执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnpm install electron-prebuilt -g
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.获取官方实例&lt;/h3&gt;
&lt;p&gt;在终端执行以下命令或者直接到&lt;a href=&quot;https://github.com/atom/electron-quick-start&quot;&gt;https://github.com/atom/electron-quick-start&lt;/a&gt;下载整个项目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/atom/electron-quick-start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;发布项目&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.安装打包工具&lt;/h3&gt;
&lt;p&gt;因为我们需要将我们的源代码进行混淆打包，免得别人看到源码。我们在终端执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g asar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.打包项目&lt;/h3&gt;

&lt;p&gt;命令 &lt;code&gt;asar pack|p [options] &amp;lt;dir&amp;gt; &amp;lt;output&amp;gt; &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里在终端进到刚才下载的官方例子文件夹外,执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asar p electron-quick-start app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改打包后的文件后缀，修改为app.asar。这里说明的是一定要以app为打包文件名称。打包之后然后到&lt;a href=&quot;https://github.com/atom/electron/releases&quot;&gt;https://github.com/atom/electron/releases&lt;/a&gt;。笔者这里是Mac系统，下载的是electron-v0.36.10-darwin-x64.zip。解压，把app.asar拷贝到&lt;code&gt;Electron.app/Contents/Resources/resource&lt;/code&gt;下,其它的不要做任何修改,到此算是完成源代码打包。&lt;/p&gt;

&lt;p&gt;还有修改应用名称，icon待续。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Mar 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/16-electron%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/16-electron%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8.html</guid>
        
        <category>electron</category>
        
        
      </item>
    
      <item>
        <title>查找Node.js中JavaScript内存泄漏的简单教程</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;缘由&lt;/h3&gt;

&lt;p&gt;公司同事内部分享的一篇讲解查找内存泄漏的博客，个人觉得很赞，就决定翻译一下，翻译不重要的地方会略过。英文不太好，翻译不好的地方或者有错误的地方欢迎指正。 原博客链接&lt;a href=&quot;http://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/&quot;&gt;http://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;几个月前，有一次出现内存泄漏，不得不调试，查找问题所在。我查找了一些相关的资料和文章，但是认真仔细读过之后，还是有疑惑到底应该怎么去调试查找问题的所在。&lt;/p&gt;

&lt;p&gt;我希望这篇文章对查找node中的内存泄漏有一个简单的引导。我将使用一种简单的方式来引导查找内存泄漏的问题。个人认为这种方式可以满足大部分需求。对于某些情况，这种方式可能不行。我将提供一些其他的资料供你参考。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;最小理论&lt;/h3&gt;

&lt;p&gt;JavaScript是一种垃圾回收语言。因此，所有的内存使用都是由一个node进程来管理自动的分配和回收，通过V8 JavaSript引擎。&lt;/p&gt;

&lt;p&gt;V8 怎么知道什么时候去回收内存？在程序中，从跟节点开始，V8有数据图始终保存所有变量的。在JavaScript中有四种数据类型。真假值，字符串，数字和对象。前3种都是简单类型，这3种数据类型能够保存数据指向他们。对象和其它所有类型都是对象类型(数组也是对象类型)，都能保存引用指向其它的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/30/15/memory-graph.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;V8周期性的根据这个内存引用列表，试着查找一些从根节点无法查找到的数据。如果这些数据无法在根节点上查找到，V8 就确认这些数据不在被使用并且释放掉这些内存。这个机制被叫做垃圾回收。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;什么时候会发生内存泄漏？&lt;/h3&gt;

&lt;p&gt;在JavaScript中内存泄漏发生在当数据不需要，在根节点中依然可以查找到时。 V8 会认为这些数据依然在使用而且不会释放掉这些数据对应的内存。&lt;strong&gt;为了能够调试内存泄漏问题，我们需要保存该数据通过错误调用，并且确保V8 能够去清理掉&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;非常重要的是要记住，垃圾回收并不是每时每刻都在清理。一般V8 在认为合适的情况下会执行垃圾回收。例如，V8 会周期性的执行垃圾回收，或者当V8 发现剩余内存变少到一定量的时候也会执行一次垃圾回收。节点有所有变量的内存链连接所有的进程，因此V8能够智能地随时调用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/30/15/node-error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;未完待续。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Jan 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/15.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/15.html</guid>
        
        <category>内存泄漏</category>
        
        <category>Node.js</category>
        
        
      </item>
    
      <item>
        <title>gulp在egret引擎中使用教程</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;缘由&lt;/h3&gt;

&lt;p&gt;作为一名伪前端攻城师，还是有必要学习一下前端工具和前端框架的。于是自己就折腾了一下，通过在egret引擎中使用gulp，来学习gulp的使用。这里是别人已经收集整理好的，gulp比较齐全的资料&lt;a href=&quot;https://github.com/Platform-CUF/use-gulp&quot;&gt;https://github.com/Platform-CUF/use-gulp&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;gulp&quot;&gt;gulp简介&lt;/h3&gt;

&lt;p&gt;Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。&lt;/p&gt;

&lt;p&gt;在egret中，这里就是希望使用它编译TypeScript文件，虽然egret已经做了一些封装，满足了基本的需求，这里完全就是自己折腾，用前端工具，做一些定制化的操作。然后实现一些定制化的功能，比如压缩资源。比如模块编译。等等。&lt;/p&gt;

&lt;h3 id=&quot;gulp-1&quot;&gt;gulp安装&lt;/h3&gt;

&lt;h4 id=&quot;gulp-2&quot;&gt;1.全局安装gulp：&lt;/h4&gt;

&lt;p&gt;&lt;code&gt; $ npm install gulp -g &lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果安装失败，前面可以添加一个sudo&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;sudo npm install gulp -g&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;因为可能被国内的某些原因，无法正常安装。大家可以安装&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;淘宝镜像&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;devdependencies&quot;&gt;2.作为项目的开发依赖（devDependencies）安装：&lt;/h4&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev gulp&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里是到项目根目录安装的。即egret项目的根目录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在egret项目根目录创建gulpfile.js文件。代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
gulp.task(&#39;default&#39;, function() {
  // 将你的默认的任务代码放在这
  
  console.log(&quot;hello gulp&quot;)
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入:&lt;code&gt;gulp&lt;/code&gt; , &lt;br /&gt;
终端输出内容中会有单独的一行，显示内容为&lt;code&gt; hello gulp&lt;/code&gt;;&lt;/p&gt;

&lt;h4 id=&quot;typescript&quot;&gt;3.编译TypeScript&lt;/h4&gt;

&lt;p&gt;在egret中，输入egret  build  则egret引擎会构建项目，TypeScript文件生成对应JavaScript文件，文件生成的目录是bin-debug。&lt;/p&gt;

&lt;p&gt;在这里使用gulp来构建，我们同样默认还是生成在bin-debug文件目录下。&lt;br /&gt;
在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev gulp-typescript&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在egret中，构建项目使用的命令是egret  build ,这里我们就创建一个build任务,gulpfile.js编写代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;)
gulp.task(&#39;default&#39;, function() {
  // 将你的默认的任务代码放在这
   console.log(&quot;hello gulp&quot;);
});

//创建一个build 任务
gulp.task(&#39;build&#39;, function() {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
        	  &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入: gulp build ,&lt;br /&gt;
我们查看对应的bin-debug目录下的JavaScript文件，是完全对应TypeScript文件生成的。&lt;br /&gt;
这里我们就实现了egret  build 功能。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里在终端输入gulp build 时候，终端会输出比较多的错误提示，说是没有引用对应的库文件。&lt;br /&gt;
接下来我们解决这个报错问题，我们引用新的gulp插件，直接调用egret默认提供的命令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev gulp-shell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们用shell脚本，调用egret引擎默认提供的命令功能。在gulpfile.js中编写对应的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});


gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用egret run －a 命令,实现增量编译
gulp.task(&#39;run&#39;, function(){
   gulp.src(&#39;&#39;)
   .pipe(shell([
       &#39;egret build -e&#39;,
       &#39;egret run -a&#39;
   ]))
    
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;egret&quot;&gt;4.发布Egret项目&lt;/h4&gt;

&lt;p&gt;这里我们同样使用egret自带的命令。参考步骤3中编译操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish
gulp.task(&#39;publish&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish &#39; 
        ]))
})


&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;发布我们这里基本的已经实现了，但是egret官方提供的可以默认的添加版本号，这里我们用另外的插&lt;br /&gt;
件yargs来实现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev yargs&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;gulpfile.js中添加代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);
var argv = require(&#39;yargs&#39;).argv;

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish --version 1000
gulp.task(&#39;publish&#39;, function () {

    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish --version &#39; +argv.version
        ]))
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，我们就完成了egret提供的基本相同的功能。剩下的就是我们的自定义功能了。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;5.自定义功能&lt;/h4&gt;

&lt;h5 id=&quot;section-2&quot;&gt;5.1压缩图片资源&lt;/h5&gt;

&lt;p&gt;安装压缩插件，在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install --save-dev gulp-imagemin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后新建一个imagemin的任务，代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);
var argv = require(&#39;yargs&#39;).argv;
var image = require(&#39;gulp-imagemin&#39;);


gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish --version 1000
gulp.task(&#39;publish&#39;, function () {

    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish --version &#39; + argv.version
        ]))
})


// 压缩图片功能 gulp imagemin
gulp.task(&#39;imagemin&#39;, function () {
    gulp.src(&#39;resource/**/*.{png,jpg,gif}&#39;)
        .pipe(image({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            interlaced: true //类型：Boolean 默认：false 隔行扫描gif进行渲染
           
        }))
        .pipe(gulp.dest(&#39;bin-release/resource&#39;));
});


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合imagemin-pngquant 来实现深度压缩资源。&lt;br /&gt;
安装压缩插件，在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install imagemin-pngquant --save-dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后修改一下资源压缩代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);
var argv = require(&#39;yargs&#39;).argv;
var image = require(&#39;gulp-imagemin&#39;);
var pngquant = require(&#39;imagemin-pngquant&#39;);

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish --version 1000
gulp.task(&#39;publish&#39;, function () {

    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish --version &#39; + argv.version
        ]))
})


// 压缩图片功能 gulp imagemin
gulp.task(&#39;imagemin&#39;, function () {
    gulp.src(&#39;resource/**/*.{png,jpg,gif}&#39;)
        .pipe(image({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            use: [pngquant()]//使用pngquant深度压缩png图片的imagemin插件
        }))
        .pipe(gulp.dest(&#39;bin-release/resource&#39;));
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的压缩是全部压缩，如何实现增量压缩资源，这里使用其它的插件来实现。&lt;br /&gt;
安装压缩插件，在egret项目根目录下，命令行中输入以下命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install gulp-cache --save-dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;修改gulpfile.js代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var ts = require(&#39;gulp-typescript&#39;);
var shell = require(&#39;gulp-shell&#39;);
var argv = require(&#39;yargs&#39;).argv;
var image = require(&#39;gulp-imagemin&#39;);
var pngquant = require(&#39;imagemin-pngquant&#39;);
var cache = require(&#39;gulp-cache&#39;);

gulp.task(&#39;default&#39;, function () {
    // 将你的默认的任务代码放在这
    console.log(&quot;hello gulp&quot;);
});

// gulp build  编译egret项目
gulp.task(&#39;build&#39;, function () {
    // 1. 找到文件
    gulp.src(&#39;src/**/*.ts&#39;)
    // 2. 编译TypeScript文件
        .pipe(ts({
            &quot;compilerOptions&quot;: {
                &quot;target&quot;: &quot;ES6&quot;,
                &quot;outDir&quot;: &quot;bin-debug&quot;,
                &quot;sourceMap&quot;: true
            },
            &quot;exclude&quot;: [
                &quot;bin-debug&quot;,
                &quot;bin-release&quot;,
                &quot;resource&quot;
            ]
        }))
    // 3. 保存编译后的文件
        .pipe(gulp.dest(&#39;bin-debug&#39;));
})

//调用 gulp run ,利用egret提供的实现增量编译
gulp.task(&#39;run&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret run -a&#39;
        ]))

});


// 发布 gulp publish --version 1000
gulp.task(&#39;publish&#39;, function () {
    gulp.src(&#39;&#39;)
        .pipe(shell([
            &#39;egret build -e&#39;,
            &#39;egret publish --version &#39; + argv.version
        ]))
})


// 压缩图片功能 gulp imagemin
gulp.task(&#39;imagemin&#39;, function () {
    gulp.src(&#39;resource/**/*.{png,jpg,gif}&#39;)
        .pipe(cache(image({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            use: [pngquant()]//使用pngquant深度压缩png图片的imagemin插件
        })))
        .pipe(gulp.dest(&#39;bin-release/resource&#39;));//压缩资源后的保存路径，这里可以填写发布后的路径
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-3&quot;&gt;5.2添加版本控制&lt;/h5&gt;

&lt;p&gt;未完待续…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 04:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/14.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/14.html</guid>
        
        <category>egret</category>
        
        <category>gulp</category>
        
        
      </item>
    
      <item>
        <title>egret(前端)＋Node.js(后端)实现跨屏互动教程</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;原理讲解&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/yuanli.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;图讲解&lt;/h3&gt;

&lt;h4 id=&quot;server&quot;&gt;server端&lt;/h4&gt;

&lt;p&gt;server端主要做信息接收和传递以及一些处理。可以理解为一个中转站。&lt;/p&gt;

&lt;h4 id=&quot;show&quot;&gt;show端&lt;/h4&gt;

&lt;p&gt;show端就是一个展示端，比如小霸王游戏机中需要的显示器。&lt;/p&gt;

&lt;h4 id=&quot;control&quot;&gt;control端&lt;/h4&gt;

&lt;p&gt;control端就好像小霸王游戏中的手柄，来操作游戏。&lt;/p&gt;

&lt;p&gt;通信协议websocket&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;流程讲解&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;show端。生成一个随机数(xxx)，作为自己唯一的ID验证。同时连接server服务器并把自己ID传输过去，标记此WebSocket连接为show端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;server端，记录步骤1中，连接过来的show端，同时记录ID(xxx)和身份标记show端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;手机扫描show端游戏页面的二维码(二维码包含show端生成的随机数ID),打开control端，连接server服务器端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;server端，对步骤3连接的WebSocket进行判断，通过ID，把show端和control端连接起来。同时标记此WebSocket为control端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这两个WebSocket连接就连接起来了，就可以进行通信，信息数据交流了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说明：为什么要有唯一的ID呢，因为这里的demo是一个show端对应一个control端的需求。可以满足多个人，同时打开show端，然后拿起手机扫描二维码，进行游戏操作。(这里如果想做多人控制一个比如，多人同时摇手机，给加油鼓劲。)&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;服务端代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var controlArr = new Array();//记录所有control端的连接
var showArr = new Array();//记录所有show端的连接

var ws = require(&#39;./node_modules/nodejs-websocket&#39;);
var server = ws.createServer(function (connection) {
	connection.data = null;
	connection.type = null;
	console.log(&quot;new connetion&quot;);
	console.log(&quot;连接数connection = &quot; + server.connections.length);
	//接收数据
	connection.on(&quot;text&quot;, function (str) {
		var data = JSON.parse(str);
		console.log(&quot;userid =&quot;,data.userid,&quot;type =&quot;,data.type);
		if (connection.data === null) {
			
			/**
			 * 1.判断链接是control端还是show端
			 * 2.如果是control端，且是第一次发送消息，什么都不做
			 * 3.如果是control端，不是第一次发送消息，那给所有的show端发送消息请求，游戏开始。
			 * 4.show端接受消息，对应的唯一show端，做相对应的处理，并返回消息。
			 * 5.游戏正式开始
			 */

			if (data.type == &quot;control&quot;) {
				controlArr.push(connection);
			} else if (data.type == &quot;show&quot;) {
				showArr.push(connection);
			}
			
			connection.userid = data.userid;
			connection.type = data.type;


			//如果是第一次发送消息什么都不做。
			if (data.event == &quot;HelloWebSocket&quot;) {
				return;
			}
			
			//如果发送消息的是控制端
			if (data.type == &quot;control&quot;) {
				var msg1 = { userid: connection.userid, type: connection.type, event: data.event, leftOrRight: data.leftOrRight };
				var sendMsg1 = JSON.stringify(msg1);
				sendMessageToShow(sendMsg1);

			}

			//如果发送消息的是show端
			if(data.type == &quot;show&quot;)
			{
				var msg2 = { userid: connection.userid, type: connection.type, event: data.event, leftOrRight: data.leftOrRight };
				var sendMsg2 = JSON.stringify(msg2);
				sendMessageToControl(sendMsg2);
			}

		} else {
			broadcast(&quot;[&quot; + connection.userid + &quot;] &quot; + connection.userid);
			console.log(&quot;connection.userid = &quot; + connection.userid);
		}

	});

	connection.on(&quot;close&quot;, function () {
		var data = { userid: connection.userid, type: connection.type, event: &quot;leave&quot;, leftOrRight: &quot;null&quot; };
		var str = JSON.stringify(data);
		broadcast(str);
		console.log(&quot;userid =&quot;,data.userid,&quot;type =&quot;,data.type,&quot; close&quot;);

		console.log(&quot;连接数connection = &quot; + server.connections.length);
	});

	connection.on(&quot;error&quot;, function () {
		if (connection.type == &quot;control&quot;) {
			var indexControl = controlArr.indexOf(connection);
			if (indexControl != -1) {
				controlArr.splice(indexControl, 1);

			}
		}
		if (connection.type == &quot;show&quot;) {
			var indexShow = controlArr.indexOf(connection);
			if (indexShow != -1) {
				controlArr.splice(indexShow, 1);

			}
		}

	});
})
server.listen(8001);
/**
 * 
 * 发送消息到所有连接
 */
function broadcast(str) {
	server.connections.forEach(function (connection) {
		connection.sendText(str);
	})
}
/**
 * 
 * 发送消息到control(控制)端
 */
function sendMessageToControl(str) {
	server.connections.forEach(function (connection) {
		if (connection.type == &quot;control&quot;) {
			connection.sendText(str);
		}
	})
}
/**
 * 
 * 发送消息到show(表现)端
 */
function sendMessageToShow(str) {
	server.connections.forEach(function (connection) {
		if (connection.type == &quot;show&quot;) {
			connection.sendText(str);
		}
	})
}

console.log(&quot;服务器启动&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;模块介绍&lt;/h3&gt;

&lt;p&gt;这里使用的是别人封装好的模块&lt;a href=&quot;https://www.npmjs.com/package/nodejs-websocket&quot;&gt;nodejs-websocket&lt;/a&gt;,点击链接,可以查看详细的API介绍和使用方法的介绍。&lt;/p&gt;

&lt;p&gt;这里就只介绍整个操作流程，从创建过程到代码的编写。请先确保电脑已经安装nodejs，如果不会安装请谷歌或者百度,&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;官网链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装之后，全局安装nodejs-websocket。在终端执行&lt;code&gt;sudo npm install nodejs-websocket -g&lt;/code&gt;。更详细的教程查看&lt;a href=&quot;https://github.com/sitegui/nodejs-websocket&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我这里使用的是Mac系统，如果不是Mac系统，大家可以对比一下查看。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;操作步骤&lt;/h3&gt;

&lt;h4 id=&quot;section-6&quot;&gt;1.安装依赖模块&lt;/h4&gt;
&lt;p&gt;打开终端,输入cd,然后拖拽文件目录,回车&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入&lt;code&gt;mkdir crossscreen &amp;amp;&amp;amp; cd crossscreen&lt;/code&gt;，这里是创建crossscreen文件夹并进入crossscreen文件夹&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入&lt;code&gt;mkdir server &amp;amp;&amp;amp; cd server&lt;/code&gt;，这里是创建server文件夹并进入server文件夹&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入&lt;code&gt;npm install nodejs-websocket&lt;/code&gt;,然后回车,安装成功终端应该是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统文件目录应该是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里说一下，有的Mac可能执行的图不是和我这里表现的一样，因为我这里安装了&lt;a href=&quot;http://ohmyz.sh/&quot;&gt;zsh&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;serverjs&quot;&gt;2.编写server.js代码&lt;/h4&gt;

&lt;p&gt;因为这里编辑纯js代码，这里使用的编辑器是VS code.&lt;/p&gt;

&lt;p&gt;把server文件夹下内容导入VS code,然后创建server.js文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来，大家就可以把代码拷贝到我们创建的server.js里面。&lt;/p&gt;

&lt;p&gt;如果想运行server.js ,直接在终端输入&lt;code&gt;node server.js&lt;/code&gt; 中间隔着空格,记住要在server文件夹下，或者直接拖拽到终端也行。&lt;br /&gt;
结果应该是这样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;3.代码讲解&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var ws = require(&#39;./node_modules/nodejs-websocket&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引用依赖库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var server = ws.createServer(function (connection) {
	
	})
	
	server.listen(8001);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建server,监听8001端口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;connection.on(&quot;text&quot;, function (str) {});
connection.on(&quot;close&quot;, function (str) {});
connection.on(&quot;error&quot;, function (str) {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;监听传送过来的数据&lt;br /&gt;
监听连接关闭&lt;br /&gt;
监听连接错误&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;扩展思路&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;数据格式&lt;/h3&gt;

&lt;p&gt;数据格式，这里使用的是使用的JSON来传送数据。如果想在egret中使用&lt;code&gt;protobuf&lt;/code&gt;,请查看&lt;a href=&quot;http://www.cnblogs.com/yangxiao/p/4686729.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因为这里比较简单所以就是定义的如下格式，这个可以根据自己的习惯来定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	&quot;userid&quot;: &quot;&quot;,
	&quot;type&quot;: &quot;&quot;,
	&quot;event&quot;: &quot;&quot;,
	&quot;data&quot;: &quot;&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;声明类 &lt;code&gt;Message&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Message {
	constructor(userid:string,event:string,type:string,data:string) {
		this.userid = userid;
		this.type = type;
		this.event = event;
		this.data = null;
	}
	userid:string = null;
	type:string = null;//  &quot;show&quot; or &quot;control&quot;
	event:string = null;// &quot;gameStart&quot;
	data:string = null;//“left”，“right”
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用&lt;code&gt;JSON.parse(),JSON.stringify()&lt;/code&gt;来转换。&lt;/p&gt;

&lt;h3 id=&quot;websocket&quot;&gt;WebSocket&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class WebSocket {
	constructor() {

	}

	static instance: WebSocket = new WebSocket();
	webSocket: egret.WebSocket = new egret.WebSocket();
	
	static getInstance(): MyWebSocket {
	
		return WebSocket.instance;
	}
	//初始化
	init(url:string,port:any): void {
		//接收消息
		this.webSocket.addEventListener(egret.ProgressEvent.SOCKET_DATA, this.onReceiveMessage, this);
		//连接
		this.webSocket.addEventListener(egret.Event.CONNECT, this.onSocketOpen, this);
		
		this.webSocket.connect(url, port);
		//添加链接关闭侦听，手动关闭或者服务器关闭连接会调用此方法
        this.webSocket.addEventListener(egret.Event.CLOSE, this.onSocketClose, this);
        //添加异常侦听，出现异常会调用此方法
        this.webSocket.addEventListener(egret.IOErrorEvent.IO_ERROR, this.onSocketError, this);
	}
	
	/**
	 * 连接成功
	 */
	private onSocketOpen(): void {
		var cmd = new Message(GlobalData.userid,&quot;HelloWebSocket&quot;,&quot;show&quot;,&quot;null&quot;);
		var msg = JSON.stringify(cmd);
		console.log(&quot;连接成功，发送数据：&quot; + msg);
		
		this.webSocket.writeUTF(msg);
	}
	/**
	 * 传送数据
	 */
	sendMesssage(str:string)
	{
		this.webSocket.writeUTF(str);
		this.webSocket.flush();
	}
	/**
	 * 接收消息
	 */
	onReceiveMessage(e: egret.Event): void {
		var msg = this.webSocket.readUTF();
		var event = new game.SceneEvent(game.SceneEvent.ChangeScene);//自定义的事件来传送数据

		event.eventData = JSON.parse(msg); //转换字符串为JSON格式

		if(GlobalData.userid == event.eventData.userid)// 判断是否是属于同一组连接
		game.ViewManager.getInstance().dispatchEvent(event)
	}

	private onSocketClose(): void {
        console.log(&quot;WebSocketClose&quot;);
    }

    private onSocketError(): void {
        console.log(&quot;WebSocketError&quot;);
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多的使用方式查看&lt;a href=&quot;http://edn.egret.com/cn/apidoc/index/name/egret.WebSocket&quot;&gt;API&lt;/a&gt;;&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;二维码&lt;/h3&gt;

&lt;p&gt;二维码使用的库是&lt;a href=&quot;https://github.com/cxh612/qrCode&quot;&gt;https://github.com/cxh612/qrCode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;具体的使用功能可以查看readme.md&lt;/p&gt;

&lt;h3 id=&quot;url&quot;&gt;解析URL&lt;/h3&gt;

&lt;p&gt;API 使用&lt;a href=&quot;http://edn.egret.com/cn/apidoc/index/name/egret.globalFunction#getOption&quot;&gt;egret.getOption&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;扩展思路&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;手机做遥感，pc做显示器。&lt;/li&gt;
  &lt;li&gt;体感游戏，手机做感应器，pc做显示端。&lt;/li&gt;
  &lt;li&gt;两个手机，情侣之间，朋友之间的对抗赛，同步屏幕操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-12&quot;&gt;代码部署&lt;/h2&gt;

&lt;h3 id=&quot;section-13&quot;&gt;说在之前&lt;/h3&gt;

&lt;p&gt;因为个人的一些习惯癖好，不喜欢PHP，写起来感觉好难受。再一个Node.js又比较火，又可以使用TypeScript来编写，于是很愉快的决定使用Node.js了。写玩之后，发现找一个支持node.js的服务器好难，在这个上面折腾了好久。游戏1天半差不多就写完了，结果部署折腾了快一个星期的时间，因为不是很懂服务器，没有办法。最后只好找同学来指点一下，然后就自己折腾去了。最后买了阿里云。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;服务器&lt;/h3&gt;

&lt;p&gt;我这里购买的是阿里云，配置的镜像是Ubuntu 14.04 64位。因为个人相比而言，相对于来说偏向Linux服务器，对于Ubuntu 更熟悉一些。这个根据个人的习惯爱好就行。有兴趣的，可以先在本地电脑安装虚拟机，然后安装Ubuntu。如果你不愿意折腾，那就直接购买就好了。如果购买阿里云，可以到网上找一些优惠码，这个阿里云还是固定发送一些的。我的推荐码xy0glk &lt;a href=&quot;https://ecs-buy.aliyun.com/#/prepay&quot;&gt;阿里云购买地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;nodejs&quot;&gt;安装Node.js&lt;/h3&gt;

&lt;p&gt;因为只当服务器使用，这里说一下安装Node.js，在Ubuntu下，node 这个命令可能被占用，一般使用nodejs 命令.如果不想换,继续使用node命令,那么查看&lt;a href=&quot;http://blchen.com/solution-for-ubuntu-node-command-invalid/&quot;&gt;这里&lt;/a&gt;。&lt;a href=&quot;http://mclspace.com/2015/12/09/aliyun-build-nodejs-environment/&quot;&gt;具体的操作可以查看这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;sftp&quot;&gt;sftp上传&lt;/h3&gt;

&lt;p&gt;这里使用的是Yummy FTP,购买阿里云之后会给你发一份邮件给你。&lt;br /&gt;
&lt;img src=&quot;/uploads/2016/1/12/13/9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入IP，用户名，端口号,然后就可以连接了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后上传服务器端代码&lt;br /&gt;
&lt;img src=&quot;/uploads/2016/1/12/13/11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后进入终端连接，启动服务器端代码,&lt;a href=&quot;https://help.aliyun.com/knowledge_detail/5974445.html?spm=5176.775974781.0.0.dqguq5&quot;&gt;更详细的教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/12/13/12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 12 Jan 2016 02:28:39 +0000</pubDate>
        <link>http://xsstomy/articles/13.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/13.html</guid>
        
        <category>egret</category>
        
        <category>node.js</category>
        
        <category>跨屏互动</category>
        
        
      </item>
    
      <item>
        <title>设计模式</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;这里会简单的介绍一下设计模式的存在意义和历史发展，这样会有一个联想记忆，可能理解会更深刻一些，让自己会思索更深层次的内容，而不是简单背诵一些简单的原则或者原理。这里笔者推荐&lt;strong&gt;《设计模式之蝉》&lt;/strong&gt; 这本书来学习&lt;strong&gt;设计模式&lt;/strong&gt;来&lt;strong&gt;面向对象编程&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;设计模式意义&lt;/h3&gt;

&lt;p&gt;在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。(&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)&quot;&gt;维基百科&lt;/a&gt;)能够高效重复的利用已有的资源而不重复的造轮子。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;设计模式历史&lt;/h3&gt;

&lt;p&gt;建筑师克里斯托佛·亚历山大在1977/79年编制了一本汇集&lt;strong&gt;设计模式&lt;/strong&gt;的书，但是这种设计模式的思想在建筑设计领域里的影响远没有后来在软件开发领域里传播的广泛。&lt;/p&gt;

&lt;p&gt;肯特·贝克和沃德·坎宁安在1987年，利用克里斯托佛·亚历山大在建筑设计领域里的思想开发了设计模式并把此思想应用在Smalltalk中的图形用户接口（GUI）的生成中。一年后埃里希·伽玛在他的苏黎世大学博士毕业论文中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien 在1989年至1991年也在利用相同的思想致力于C++的开发，而后于1991年发表了他的著作Advanced C++ Programming Styles and Idioms。同年Erich Gamma 得到了博士学位，然后去了美国，在那与Richard Helm, Ralph Johnson ,John Vlissides 合作出版了&lt;strong&gt;《设计模式：可复用面向对象软件的基础》&lt;/strong&gt;（Design Patterns - Elements of Reusable Object-Oriented Software） 一书，在此书中共收录了23个设计模式。&lt;/p&gt;

&lt;p&gt;这四位作者在软件开发领域里以“四人帮”（英语，Gang of Four，简称GoF）而闻名，并且他们在此书中的协作导致了软件设计模式的突破。有时，GoF也会用于代指《设计模式》这本书。[&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)&quot;&gt;维基百科&lt;/a&gt;]&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;设计模式六大原则&lt;/h3&gt;

&lt;p&gt;这里依然是从结构入手，这样大脑有一个大体的认识和印象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2016/1/9/12/designpattern.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图结构主要两大块：&lt;/p&gt;

&lt;p&gt;1.单一接口，类，方法的设计(&lt;strong&gt;单一原则&lt;/strong&gt;，&lt;strong&gt;接口分离原则&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;2.类与类之间关系的设计(&lt;strong&gt;里氏替换&lt;/strong&gt;,&lt;strong&gt;依赖倒置&lt;/strong&gt;,&lt;strong&gt;迪米特&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;3.设计之初考虑的原则(&lt;strong&gt;开闭原则&lt;/strong&gt;)&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;设计模式演变&lt;/h3&gt;

&lt;p&gt;笔者认真的过了一遍演变的23种设计模式，都是适用于一定的特殊场景。阅读过程中认真的验证了一下这23种模式，都是遵守上述设计模式的六大原则，所以笔者推荐的是认真领悟设计模式的六大原则，在实际生产中，自己怎么使用舒服同时也能满足项目的需求，那就怎么用。因为最终的需求还是满足项目的需求，完成项目。如果非要推荐，个人推荐&lt;strong&gt;工厂模式&lt;/strong&gt;,&lt;strong&gt;观察者模式&lt;/strong&gt;,&lt;strong&gt;桥接模式&lt;/strong&gt;,&lt;strong&gt;原型模式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Jan 2016 18:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/12.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/12.html</guid>
        
        <category>设计模式</category>
        
        <category>设计模式之蝉</category>
        
        
      </item>
    
      <item>
        <title>2016计划</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;不知不觉2015年过去了，回望2015年，觉得自己过的很惭愧，虽然有一点进步，但是还是不够。于是好好整理计划2016。望2017年回望2016年，不要太多遗憾。勉励自己一句话：人生苦短，及时行乐。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2015/12/31/11/2016.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 31 Dec 2015 08:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/11.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/11.html</guid>
        
        <category>2016</category>
        
        
      </item>
    
      <item>
        <title>ECMAScript 2015新特性</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;缘由&lt;/h2&gt;
&lt;p&gt;继上一篇翻译的文章&lt;a href=&quot;http://xsstomy.com/articles/9.html&quot;&gt;使用TypeScript开发React&lt;/a&gt;之后，对翻译文章有点上瘾了。最近也在研究ES2015,找到一篇不错的文章，于是又开始翻译起来了，就有了这篇博客。&lt;a href=&quot;https://github.com/lukehoban/es6features#readme&quot;&gt;原文链接&lt;/a&gt;。下面正式翻译了，翻译并不是全文对比翻译的，也加了部分自己查找到资料的整理。&lt;/p&gt;

&lt;h2 id=&quot;ecmascript6&quot;&gt;ECMAScript6&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;ECMAScript 6,又名ECMAScript 2015,是ECMAScript 标准的最新版本。ES6是一个重要的更新对于JavaScript，并且这次更新是ES5在2009更新之后的首次更新。这些功能的正在集成在大部分&lt;a href=&quot;http://kangax.github.io/es5-compat-table/es6/&quot;&gt;JavaScript引擎&lt;/a&gt;中。&lt;/p&gt;

&lt;p&gt;查看&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ES6 标准&lt;/a&gt;都在这篇详细的说明书中。&lt;/p&gt;

&lt;p&gt;ES6 包含以下新的功能点:&lt;br /&gt;
- &lt;a href=&quot;#箭头操作符&quot;&gt;箭头操作符&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#类的支持&quot;&gt;类的支持&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#增强的对象字面量&quot;&gt;增强的对象字面量&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#字符串模板&quot;&gt;字符串模板&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#解构&quot;&gt;解构&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#参数默认值，剩余参数，拓展参数&quot;&gt;参数默认值，剩余参数，拓展参数&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#let与const关键字&quot;&gt;let与const 关键字&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#迭代器，for..of&quot;&gt;迭代器，for..of&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#generator&quot;&gt;generator&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#字符编码标准&quot;&gt;字符编码标准&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#模块&quot;&gt;模块&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#模块装载&quot;&gt;模块装载&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#Map,Set和WeekMap,WeakSet&quot;&gt;Map，Set 和 WeakMap，WeakSet&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#Proxies&quot;&gt;Proxies&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#Symbols类型&quot;&gt;Symbols类型&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#子类内置&quot;&gt;子类内置&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#Promises&quot;&gt;Promises&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#Math，Number，String，Object的新API&quot;&gt;Math，Number，String，Object 的新API&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#二进制和八进制&quot;&gt;二进制和八进制&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#反射API&quot;&gt;反射API&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;#递归调用&quot;&gt;递归调用&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ecmascript6-&quot;&gt;ECMAScript6 新特性&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;箭头操作符&lt;/h3&gt;
&lt;p&gt;箭头操作符是函数简写的一种表现行式。它在语法结构上比较像C#,Java8和CoffeeScript里面的功能。它同时支持两种使用方式，表达式方式和声明方式。与function申明方式不同的地方是，箭头操作符号能够在相同的代码编辑模块中保留相同的&lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 表达式方式
var odds = evens.map(v =&amp;gt; v + 1);
var nums = evens.map((v, i) =&amp;gt; v + i);
var pairs = evens.map(v =&amp;gt; ({even: v, odd: v + 1}));

// 申明方式
nums.forEach(v =&amp;gt; {
  if (v % 5 === 0)
    fives.push(v);
});

// 词汇 this
var bob = {
  _name: &quot;Bob&quot;,
  _friends: [],
  printFriends() {
    this._friends.forEach(f =&amp;gt;
      console.log(this._name + &quot; knows &quot; + f));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;类的支持&lt;/h3&gt;
&lt;p&gt;ES6 类是一个语法糖通过对JS原型模式的包装来实现。有一个简单类型申明形式使得类模式更加方便使用。类支持原型为基础的继承，super调用，实例和静态方法和构造函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SkinnedMesh extends THREE.Mesh {
  constructor(geometry, materials) {
    super(geometry, materials);

    this.idMatrix = SkinnedMesh.defaultMatrix();
    this.bones = [];
    this.boneMatrices = [];
    //...
  }
  update(camera) {
    //...
    super.update();
  }
  get boneCount() {
    return this.bones.length;
  }
  set matrixType(matrixType) {
    this.idMatrix = SkinnedMesh[matrixType]();
  }
  static defaultMatrix() {
    return new THREE.Matrix4();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;增强的对象字面量&lt;/h2&gt;
&lt;p&gt;对象字面量扩展到支持设置背景原型，简写为Foo Foo作业：定义方法，使super调用，和计算属性名称和表达式。另外，这些也给对象的文字和类声明更紧密的结合在一起，让对象设计受益于一些相同的便利&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
    // __proto__
    __proto__: theProtoObj,
    // Shorthand for ‘handler: handler’
    handler,
    // Methods
    toString() {
     // Super calls
     return &quot;d &quot; + super.toString();
    },
    // Computed (dynamic) property names
    [ &#39;prop_&#39; + (() =&amp;gt; 42)() ]: 42
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;字符串模板&lt;/h2&gt;
&lt;p&gt;字符串模板提供构造字符串语法糖,这个类似在Perl,Python和更多的字符串插值功能。可选的，可以添加一个标记，以允许字符串结构来进行定制，避免从字符串内容里注入攻击或构造更高级别的数据结构。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 基础的字符串
`In JavaScript &#39;\n&#39; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.&quot;&quot;`&quot;&quot;

// String interpolation
&quot;var name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`&quot;

// Construct an HTTP request prefix is used to interpret the replacements and construction
POST`http://foo.org/bar?a=${a}&amp;amp;b=${b}
     Content-Type: application/json
     X-Credentials: ${credentials}
     { &quot;foo&quot;: ${foo},
       &quot;bar&quot;: ${bar}}`(myOnReadyStateChangeHandler);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;解构&lt;/h2&gt;
&lt;p&gt;解构允许结合使用模式匹配，与匹配的数组和对象的支持。解构是错误弱化，类似于标准的对象查找foo[“bar”] ，使用解构赋值访问对象中未定义的属性，将会得到undifined。更详细的用法点击&lt;a href=&quot;http://www.csdn.net/article/2015-07-07/2825149-es6-in-depth-destructuring&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 数组匹配
var [a, , b] = [1,2,3];

// 对象匹配
var { op: a, lhs: { op: b }, rhs: c }
       = getASTNode()

// object matching shorthand
// binds `op`, `lhs` and `rhs` in scope
var {op, lhs, rhs} = getASTNode()

// Can be used in parameter position
function g({name: x}) {
  console.log(x);
}
g({name: 5})

// Fail-soft destructuring
var [a] = [];
a === undefined;

// Fail-soft destructuring with defaults
var [a = 1] = [];
a === 1;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;参数默认值，剩余参数，拓展参数&lt;/h2&gt;
&lt;p&gt;被评估的默认参数值。在函数调用中，将数组转换为连续的参数。将…参数绑定到数组。剩余参数省略必要的&lt;code&gt;arguments&lt;/code&gt;而且在一般情况更适用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function f(x, y=12) {
  // y is 12 if not passed (or passed as undefined)
  return x + y;
}
f(3) == 15
function f(x, ...y) {
  // y is an Array
  return x * y.length;
}
f(3, &quot;hello&quot;, true) == 6
function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f(...[1,2,3]) == 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;letconst-&quot;&gt;let与const 关键字&lt;/h2&gt;
&lt;p&gt;可以把let看成var，只是它定义的变量被限定在了特定范围内才能使用，而离开这个范围则无效。const则很直观，用来定义常量，即无法被更改值的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function f() {
  {
    let x;
    {
      // okay, block scoped name
      const x = &quot;sneaky&quot;;
      // error, const
      x = &quot;foo&quot;;
    }
    // error, already declared in block
    let x = &quot;inner&quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;## 迭代器，for..of&lt;br /&gt;
迭代器对象能够像CLR的IEnumerable或Java 的Iterable。一般化的for..in定制基于迭代器的迭代与for..of。不要求实现一个数组，使懒惰的设计模式，如LINQ。ES6中新引入的for of循环功能相似，不同的是每次循环它提供的不是序号而是值。for-of循环不仅仅是为遍历数组而设计的。基本上所有类数组对象都适用，比如DOM NodeListS，也能用在字符串上。更多详细的用法可以点击&lt;a href=&quot;http://www.csdn.net/article/2015-06-15/2824965-es6-in-depth-iterators-and-the-for-of-loop&quot;&gt;这里查看&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;iterator:它是这么一个对象，拥有一个next方法，这个方法返回一个对象{done,value}，这个对象包含两个属性，一个布尔类型的done和包含任意值的value&lt;br /&gt;
iterable: 这是这么一个对象，拥有一个obj[@@iterator]方法，这个方法返回一个iterator&lt;br /&gt;
generator: 它是一种特殊的iterator。反的next方法可以接收一个参数并且返回值取决与它的构造函数（generator function）。generator同时拥有一个throw方法&lt;br /&gt;
generator 函数: 即generator的构造函数。此函数内可以使用yield关键字。在yield出现的地方可以通过generator的next或throw方法向外界传递值。generator 函数是通过function*来声明的&lt;br /&gt;
yield 关键字：它可以暂停函数的执行，随后可以再进进入函数继续执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let fibonacci = {
  [Symbol.iterator]() {
    let pre = 0, cur = 1;
    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        return { done: false, value: cur }
      }
    }
  }
}

for (var n of fibonacci) {
  // truncate the sequence at 1000
  if (n &amp;gt; 1000)
    break;
  console.log(n);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;迭代是基于这些duck类型接口(使用TypeScript 类型的语法来阐述)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface IteratorResult {
  done: boolean;
  value: any;
}
interface Iterator {
  next(): IteratorResult;
}
interface Iterable {
  [Symbol.iterator](): Iterator
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;generator&quot;&gt;generator&lt;/h2&gt;
&lt;p&gt;generator简化重复使用 &lt;code&gt;function*&lt;/code&gt;和&lt;code&gt;yield&lt;/code&gt;。声明为&lt;code&gt;function*&lt;/code&gt;函数返回一个generator实例。generator是迭代器的子类图包含一些扩展&lt;code&gt;next&lt;/code&gt;和&lt;code&gt;throw&lt;/code&gt;,这些能够使用的值将会返回到generator，因此&lt;code&gt;yield&lt;/code&gt;是一个关键字，如果return，返回一个value或者throws。&lt;a href=&quot;http://www.csdn.net/article/2015-06-15/2824967-es6-in-depth-generators&quot;&gt;更多的内容&lt;/a&gt;&lt;br /&gt;
注：也可用于启用“ await’般的异步编程，又见ES7等待提案。&lt;br /&gt;
生成器函数最大的特点是可以中断自己，但普通函数不可以。&lt;br /&gt;
```&lt;br /&gt;
var fibonacci = {&lt;br /&gt;
  [Symbol.iterator]: function*() {&lt;br /&gt;
    var pre = 0, cur = 1;&lt;br /&gt;
    for (;;) {&lt;br /&gt;
      var temp = pre;&lt;br /&gt;
      pre = cur;&lt;br /&gt;
      cur += temp;&lt;br /&gt;
      yield cur;&lt;br /&gt;
    }&lt;br /&gt;
  }&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;for (var n of fibonacci) {&lt;br /&gt;
  // truncate the sequence at 1000&lt;br /&gt;
  if (n &amp;gt; 1000)&lt;br /&gt;
    break;&lt;br /&gt;
  console.log(n);&lt;br /&gt;
}&lt;br /&gt;
```&lt;/p&gt;

&lt;p&gt;generator接口是 (使用TypeScript 类型的语法来阐述)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface Generator extends Iterator {
    next(value?: any): IteratorResult;
    throw(exception: any);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-8&quot;&gt;字符编码标准&lt;/h2&gt;
&lt;p&gt;非断补充，支持完整的Unicode ，包括串新的Unicode文本形式和新的RegExp ú模式来处理代码点，以及新的API来处理在21位的代码点水平的字符串。这些增加支持JavaScript的建立全球的应用程序。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// same as ES5.1
&quot;𠮷&quot;.length == 2

// new RegExp behaviour, opt-in ‘u’
&quot;𠮷&quot;.match(/./u)[0].length == 2

// new form
&quot;\u{20BB7}&quot;==&quot;𠮷&quot;==&quot;\uD842\uDFB7&quot;

// new String ops
&quot;𠮷&quot;.codePointAt(0) == 0x20BB7

// for-of iterates code points
for(var c of &quot;𠮷&quot;) {
  console.log(c);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-9&quot;&gt;模块&lt;/h2&gt;
&lt;p&gt;对于模块组件定义语言级的支持。将从流行的JavaScript模块装载机模式（AMD，CommonJS）。将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// lib/math.js
export function sum(x, y) {
  return x + y;
}
export var pi = 3.141593;
// app.js
import * as math from &quot;lib/math&quot;;
alert(&quot;2π = &quot; + math.sum(math.pi, math.pi));
// otherApp.js
import {sum, pi} from &quot;lib/math&quot;;
alert(&quot;2π = &quot; + sum(pi, pi));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一些附加功能包括&lt;code&gt;export default&lt;/code&gt;和&lt;code&gt;export *&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// lib/mathplusplus.js
export * from &quot;lib/math&quot;;
export var e = 2.71828182846;
export default function(x) {
    return Math.log(x);
}
// app.js
import ln, {pi, e} from &quot;lib/mathplusplus&quot;;
alert(&quot;2π = &quot; + ln(e)*pi*2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-10&quot;&gt;模块装载机模式&lt;/h2&gt;
&lt;p&gt;模块装载机支持:&lt;br /&gt;
- 动态加载&lt;br /&gt;
- 状态隔离&lt;br /&gt;
- 全局命名空间隔离&lt;br /&gt;
- 编译钩&lt;br /&gt;
- 嵌套虚拟化&lt;/p&gt;

&lt;p&gt;可以配置默认模块加载程序,新的加载程序可以构造来评估并且在分离或约束的情况下加载代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Dynamic loading – ‘System’ is default loader
System.import(&#39;lib/math&#39;).then(function(m) {
  alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));
});

// Create execution sandboxes – new Loaders
var loader = new Loader({
  global: fixup(window) // replace ‘console.log’
});
loader.eval(&quot;console.log(&#39;hello world!&#39;);&quot;);

// Directly manipulate module cache
System.get(&#39;jquery&#39;);
System.set(&#39;jquery&#39;, Module({$: $})); // WARNING: not yet finalized
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;## Map，Set 和 WeakMap，WeakSet&lt;br /&gt;
这些是新加的集合类型，提供了更加方便的获取属性值的方法，不用像以前一样用hasOwnProperty来检查某个属性是属于原型链上的呢还是当前对象的。同时，在进行属性值添加与获取时有专门的get，set 方法。有时候我们会把对象作为一个对象的键用来存放属性值，普通集合类型比如简单对象会阻止垃圾回收器对这些作为属性键存在的对象的回收，有造成内存泄漏的危险。而WeakMap,WeakSet则更加安全些，这些作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sets
var s = new Set();
s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);
s.size === 2;
s.has(&quot;hello&quot;) === true;

// Maps
var m = new Map();
m.set(&quot;hello&quot;, 42);
m.set(s, 34);
m.get(s) == 34;

// Weak Maps
var wm = new WeakMap();
wm.set(s, { extra: 42 });
wm.size === undefined

// Weak Sets
var ws = new WeakSet();
ws.add({ data: 42 });
// Because the added object has no other references, it will not be held in the set
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;proxies&quot;&gt;Proxies&lt;/h2&gt;
&lt;p&gt;Proxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。一下子让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Proxying a normal object
var target = {};
var handler = {
  get: function (receiver, name) {
    return `Hello, ${name}!`;
  }
};

var p = new Proxy(target, handler);
p.world === &#39;Hello, world!&#39;;
// Proxying a function object
var target = function () { return &#39;I am the target&#39;; };
var handler = {
  apply: function (receiver, ...args) {
    return &#39;I am the proxy&#39;;
  }
};

var p = new Proxy(target, handler);
p() === &#39;I am the proxy&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有陷阱可用于所有的运行时级元操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var handler =
{
  get:...,
  set:...,
  has:...,
  deleteProperty:...,
  apply:...,
  construct:...,
  getOwnPropertyDescriptor:...,
  defineProperty:...,
  getPrototypeOf:...,
  setPrototypeOf:...,
  enumerate:...,
  ownKeys:...,
  preventExtensions:...,
  isExtensible:...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;## Symbols类型&lt;br /&gt;
符号启用对象状态访问控制。元件使性能受到任何字符串（如ES5 ）或符号来键入。符号是一个新的基本类型。用于调试的可选参数的说明 - 而不是身份的一部分。符号是唯一的（像gensym ），但不专用，因为它们是经由像Object.getOwnPropertySymbols反射功能暴露。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MyClass = (function() {

  // module scoped symbol
  var key = Symbol(&quot;key&quot;);

  function MyClass(privateData) {
    this[key] = privateData;
  }

  MyClass.prototype = {
    doStuff: function() {
      ... this[key] ...
    }
  };

  return MyClass;
})();

var c = new MyClass(&quot;hello&quot;)
c[&quot;key&quot;] === undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;## 子类内置&lt;/p&gt;

&lt;p&gt;在ES6中，像&lt;code&gt;Array&lt;/code&gt;,&lt;code&gt;Date&lt;/code&gt; 和DOM &lt;code&gt;Element&lt;/code&gt;元素都可以被继承。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 数组的伪代码
class Array {
    constructor(...args) { /* ... */ }
    static [Symbol.create]() {
        // Install special [[DefineOwnProperty]]
        // to magically update &#39;length&#39;
    }
}

// 用户继承的子类
class MyArray extends Array {
    constructor(...args) { super(...args); }
}

// Two-phase &#39;new&#39;:
// 1) Call @@create to allocate object
// 2) Invoke constructor on new instance
var arr = new MyArray();
arr[1] = 12;
arr.length == 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;promises&quot;&gt;Promises&lt;/h2&gt;
&lt;p&gt;Promises 是一个异步编程库。Promises 是可以在未来提供价值的一个类。Promises 是用在许多现有的JavaScript库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function timeout(duration = 0) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(resolve, duration);
    })
}

var p = timeout(1000).then(() =&amp;gt; {
    return timeout(2000);
}).then(() =&amp;gt; {
    throw new Error(&quot;hmm&quot;);
}).catch(err =&amp;gt; {
    return Promise.all([timeout(100), timeout(200)]);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mathnumberstringobject-api&quot;&gt;Math，Number，String，Object 的新API&lt;/h2&gt;
&lt;p&gt;对Math,Number,String还有Object等添加了许多新的API。以下对这些新API进行了简单展示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Number.EPSILON
Number.isInteger(Infinity) // false
Number.isNaN(&quot;NaN&quot;) // false

Math.acosh(3) // 1.762747174039086
Math.hypot(3, 4) // 5
Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2

&quot;abcde&quot;.includes(&quot;cd&quot;) // true
&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;

Array.from(document.querySelectorAll(&#39;*&#39;)) // 返回一个数组
Array.of(1, 2, 3) // 类似 new Array(...), 但是没有特别的一个参数
[0, 0, 0].fill(7, 1) // [0,7,7]
[1, 2, 3].find(x =&amp;gt; x == 3) // 3
[1, 2, 3].findIndex(x =&amp;gt; x == 2) // 1
[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;

Object.assign(Point, { origin: new Point(0,0) })
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-11&quot;&gt;二进制和八进制&lt;/h2&gt;
&lt;p&gt;两个新的数字文字形式添加二进制（B）、八进制（O）。&lt;br /&gt;
&lt;code&gt;
0b111110111 === 503 // true
0o767 === 503 // true
&lt;/code&gt;&lt;br /&gt;
## 反射API&lt;br /&gt;
全部反射API暴露运行级别元的操作的对象。这是有效地代理API的反射，并且允许使得对应于相同的元的操作作为代理陷阱呼叫。尤其适用于实现代理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;暂时没有demo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;## 递归调用&lt;br /&gt;
在递归调用堆栈不保证不增长。确保在无限制的的输入情况下递归算法的安全。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function factorial(n, acc = 1) {
    &#39;use strict&#39;;
    if (n &amp;lt;= 1) return acc;
    return factorial(n - 1, n * acc);
}

// 在大多数实现中的堆栈溢出
// 但是在ES6中对于任意的输入都是安全的
factorial(100000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;## 总结&lt;br /&gt;
总结就是一句话，前后端差异越来越小了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/mypictures/xsstomyzhifubao.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Dec 2015 01:28:39 +0800</pubDate>
        <link>http://xsstomy/articles/10.html</link>
        <guid isPermaLink="true">http://xsstomy/articles/10.html</guid>
        
        <category>ES2015</category>
        
        <category>ES6</category>
        
        
      </item>
    
  </channel>
</rss>
